// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`DirectoryExpander 1`] = `
{
  "expandedContent": "=== Directory Content Summary ===
Processed Directories: 1
Total Files: 38
Successfully Read: 38
Total Size: 130.6 KB

=== Directory: src ===

--- File: src/express.d.ts ---
import 'express';
import { AgentServer } from './server';
import { AgentSession } from './core';

declare global {
  namespace Express {
    interface Locals {
      server: AgentServer;
    }

    interface Request {
      session?: AgentSession;
    }

    interface Application {
      group(
        prefix: string,
        ...handlers: (express.RequestHandler | ((router: express.Router) => void))[]
      ): void;
    }
  }
}

--- End of src/express.d.ts ---

--- File: src/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './core';
export * from './server';
export * from './utils';
export * from './storage';
export * from './types';
export * from './services';

--- End of src/index.ts ---

--- File: src/server.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import http from 'http';
import { Server as SocketIOServer } from 'socket.io';
import { setupAPI } from './api';
import { LogLevel } from '@tarko/interface';
import { StorageProvider, createStorageProvider } from './storage';
import { setupSocketIO } from './core/SocketHandlers';
import type { AgentSession } from './core';
import { resolveAgentImplementation } from './utils/agent-resolver';
import type {
  AgentServerVersionInfo,
  AgentServerInitOptions,
  AgentAppConfig,
  AgentResolutionResult,
  AgioProviderConstructor,
  IAgent,
} from './types';
import { TARKO_CONSTANTS, GlobalDirectoryOptions } from '@tarko/interface';

export { express };

/**
 * AgentServer - Generic server class for any Agent implementation
 *
 * This class orchestrates all server components including:
 * - Express application and HTTP server
 * - API endpoints
 * - WebSocket communication
 * - Session management
 * - Storage integration
 * - AGIO monitoring integration
 * - Workspace static file serving
 * - Generic Agent dependency injection
 */
export class AgentServer<T extends AgentAppConfig = AgentAppConfig> {
  // Core server components
  private app: express.Application;
  private server: http.Server;
  private io: SocketIOServer; // Socket.IO server

  // Server state
  private isRunning = false;

  // Session management
  public sessions: Record<string, AgentSession> = {};
  public storageUnsubscribes: Record<string, () => void> = {};

  // Configuration
  public readonly port: number;
  public readonly isDebug: boolean;
  public readonly storageProvider: StorageProvider | null = null;
  public readonly appConfig: T;
  public readonly versionInfo?: AgentServerVersionInfo;
  public readonly directories: Required<GlobalDirectoryOptions>;

  // Current agent resolution, resolved before server started
  private currentAgentResolution?: AgentResolutionResult;

  // Server information

  constructor(instantiationOptions: AgentServerInitOptions<T>) {
    const { appConfig, versionInfo, directories } = instantiationOptions;

    // Store injected Agent constructor and options
    this.appConfig = appConfig;

    // Store version info
    this.versionInfo = versionInfo;

    // Initialize directories with defaults
    this.directories = {
      globalWorkspaceDir: directories?.globalWorkspaceDir || TARKO_CONSTANTS.GLOBAL_WORKSPACE_DIR,
    };

    // Extract server configuration from agent options
    this.port = appConfig.server?.port ?? 3000;
    this.isDebug = appConfig.logLevel === LogLevel.DEBUG;

    // Initialize Express app and HTTP server
    this.app = express();
    this.server = http.createServer(this.app);

    // Initialize storage if provided
    if (appConfig.server?.storage) {
      this.storageProvider = createStorageProvider(appConfig.server.storage);
    }

    // Setup API routes and middleware (includes workspace static server)
    setupAPI(this.app, {
      workspacePath: this.getCurrentWorkspace(),
      isDebug: this.isDebug,
    });

    // Setup WebSocket functionality
    this.io = setupSocketIO(this.server, this);

    // Make server instance available to request handlers
    this.app.locals.server = this;
  }

  /**
   * Get the custom AGIO provider if injected
   * @returns Custom AGIO provider or undefined
   */
  getCustomAgioProvider(): AgioProviderConstructor | undefined {
    return this.currentAgentResolution?.agioProviderConstructor;
  }

  /**
   * Get the label of current agent
   */
  getCurrentWorkspace(): string {
    if (!this.appConfig?.workspace) {
      throw new Error('Workspace not specified');
    }
    return this.appConfig.workspace;
  }

  /**
   * Get the label of current agent
   */
  getCurrentAgentName(): string | undefined {
    return this.currentAgentResolution?.agentName;
  }

  /**
   * Get the Express application instance
   * @returns Express application
   */
  getApp(): express.Application {
    return this.app;
  }

  /**
   * Get the HTTP server instance
   * @returns HTTP server
   */
  getHttpServer(): http.Server {
    return this.server;
  }

  /**
   * Get the Socket.IO server instance
   * @returns Socket.IO server
   */
  getSocketIOServer(): SocketIOServer {
    return this.io;
  }

  /**
   * Check if the server is currently running
   * @returns True if server is running
   */
  isServerRunning(): boolean {
    return this.isRunning;
  }

  /**
   * Get storage information if available
   * @returns Object containing storage type and path (if applicable)
   */
  getStorageInfo(): { type: string; path?: string } {
    if (!this.storageProvider) {
      return { type: 'none' };
    }

    if (this.storageProvider.constructor.name === 'FileStorageProvider') {
      return {
        type: 'file',
        path: this.storageProvider.dbPath,
      };
    }

    if (this.storageProvider.constructor.name === 'SQLiteStorageProvider') {
      return {
        type: 'sqlite',
        path: this.storageProvider.dbPath,
      };
    }

    // For other storage types
    return {
      type: this.storageProvider.constructor.name.replace('StorageProvider', '').toLowerCase(),
    };
  }

  /**
   * Start the server on the configured port
   * @returns Promise resolving with the server instance
   */
  async start(): Promise<http.Server> {
    // Resolve agent implementation with workspace context
    const agentResolutionResult = await resolveAgentImplementation(this.appConfig.agent, {
      workspace: this.appConfig.workspace,
    });
    this.currentAgentResolution = agentResolutionResult;

    // Initialize storage if available
    if (this.storageProvider) {
      try {
        await this.storageProvider.initialize();
      } catch (error) {
        console.error('Failed to initialize storage provider:', error);
      }
    }

    return new Promise((resolve) => {
      this.server.listen(this.port, () => {
        this.isRunning = true;
        resolve(this.server);
      });
    });
  }

  /**
   * Stop the server and clean up all resources
   * @returns Promise resolving when server is stopped
   */
  async stop(): Promise<void> {
    // Clean up all active sessions
    const sessionCleanup = Object.values(this.sessions).map((session) => session.cleanup());
    await Promise.all(sessionCleanup);

    // Clean up all storage unsubscribes
    Object.values(this.storageUnsubscribes).forEach((unsubscribe) => unsubscribe());
    this.storageUnsubscribes = {};

    // Clear sessions
    this.sessions = {};

    // Close storage provider
    if (this.storageProvider) {
      await this.storageProvider.close();
    }

    // Close server if running
    if (this.isRunning) {
      return new Promise((resolve, reject) => {
        this.server.close((err) => {
          if (err) {
            reject(err);
            return;
          }

          this.isRunning = false;
          resolve();
        });
      });
    }

    return Promise.resolve();
  }

  /**
   * Create a new Agent instance using the injected constructor
   * @returns New Agent instance
   */
  createAgent(): IAgent {
    if (!this.currentAgentResolution) {
      throw new Error('Cannot found availble resolved agent');
    }
    return new this.currentAgentResolution.agentConstructor(this.appConfig);
  }
}

--- End of src/server.ts ---

--- File: src/types.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */
import { AgentAppConfig, AgentServerVersionInfo, GlobalDirectoryOptions } from '@tarko/interface';

export * from '@tarko/interface';

/**
 * Agent Server instantiation configuration
 */
export interface AgentServerInitOptions<T extends AgentAppConfig = AgentAppConfig> {
  /**
   * Agent version info
   */
  versionInfo?: AgentServerVersionInfo;
  /**
   * Global directory configuration
   */
  directories?: GlobalDirectoryOptions;
  /**
   * Agent App configuration
   */
  appConfig: T;
}

/**
 * API response structure for errors
 */
export interface ErrorResponse {
  error: string;
  message?: string;
  code?: string;
  details?: Record<string, any>;
}

/**
 * API response structure for success with data
 */
export interface SuccessResponse<T> {
  success: true;
  data: T;
}

/**
 * Session status response
 */
export interface SessionStatusResponse {
  sessionId: string;
  status: {
    isProcessing: boolean;
    state: string;
  };
}

/**
 * Browser control information response
 */
export interface BrowserControlInfoResponse {
  mode: string;
  tools: string[];
}

/**
 * Share configuration response
 */
export interface ShareConfigResponse {
  hasShareProvider: boolean;
  shareProvider: string | null;
}

/**
 * Share result response
 */
export interface ShareResultResponse {
  success: boolean;
  url?: string;
  html?: string;
  sessionId?: string;
  error?: string;
}

--- End of src/types.ts ---
=== End of Directory: src ===

=== Directory: src/api ===

--- File: src/api/index.ts ---
import express from 'express';
import cors from 'cors';
import { registerAllRoutes } from './routes';
import { setupWorkspaceStaticServer } from '../utils/workspace-static-server';

/**
 * Get default CORS options if none are provided
 *
 * TODO: support cors config.
 */
export function getDefaultCorsOptions(): cors.CorsOptions {
  return {
    origin: '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  };
}

/**
 * Setup API middleware and routes
 * @param app Express application instance
 * @param options Server options
 */
export function setupAPI(
  app: express.Application,
  options?: {
    workspacePath?: string;
    isDebug?: boolean;
  },
) {
  // Apply CORS middleware
  app.use(cors(getDefaultCorsOptions()));

  // Apply JSON body parser middleware
  app.use(express.json({ limit: '20mb' }));

  // Add app.group method
  app.group = (
    prefix: string,
    ...handlers: (express.RequestHandler | ((router: express.Router) => void))[]
  ) => {
    const router = express.Router();
    const routerCallback = handlers.pop() as (router: express.Router) => void;
    const middlewares = handlers as express.RequestHandler[];

    routerCallback(router);
    app.use(prefix, ...middlewares, router);
  };

  // Register all API routes first (highest priority)
  registerAllRoutes(app);

  // Setup workspace static server (lower priority, after API routes)
  if (options?.workspacePath) {
    setupWorkspaceStaticServer(app, options.workspacePath, options.isDebug);
  }
}

--- End of src/api/index.ts ---
=== End of Directory: src/api ===

=== Directory: src/api/controllers ===

--- File: src/api/controllers/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './sessions';
export * from './queries';
export * from './system';
export * from './share';
export * from './oneshot';

--- End of src/api/controllers/index.ts ---

--- File: src/api/controllers/oneshot.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { ChatCompletionContentPart } from '@tarko/interface';
import { nanoid } from 'nanoid';
import { SessionMetadata } from '../../storage';
import { AgentSession } from '../../core';
import { createErrorResponse } from '../../utils/error-handler';

/**
 * Interface for one-shot query request body
 */
interface OneshotQueryRequest {
  /**
   * Query content to be processed
   */
  query: string | ChatCompletionContentPart[];

  /**
   * Optional session name to identify the session
   */
  sessionName?: string;

  /**
   * Optional session tags for organization
   */
  sessionTags?: string[];
}

/**
 * Execute a query in a newly created session (non-streaming)
 */
export async function createAndQuery(req: Request, res: Response) {
  try {
    const { query, sessionName, sessionTags } = req.body as OneshotQueryRequest;

    if (!query) {
      return res.status(400).json({ error: 'Query is required' });
    }

    // Create new session
    const server = req.app.locals.server;
    const sessionId = nanoid();

    // Create session with custom AGIO provider if available
    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

    server.sessions[sessionId] = session;

    // Initialize session
    const { storageUnsubscribe } = await session.initialize();

    // Save unsubscribe function for cleanup
    if (storageUnsubscribe) {
      server.storageUnsubscribes[sessionId] = storageUnsubscribe;
    }

    // Store session metadata if storage is available
    if (server.storageProvider) {
      const metadata: SessionMetadata = {
        id: sessionId,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        name: sessionName,
        workspace: server.getCurrentWorkspace(),
        tags: sessionTags,
      };

      await server.storageProvider.createSession(metadata);
    }

    // Execute query on new session
    const response = await session.runQuery(query);

    if (response.success) {
      res.status(200).json({
        sessionId,
        result: response.result,
      });
    } else {
      // Send structured error response with 500 status
      res.status(500).json({
        sessionId,
        ...response,
      });
    }
  } catch (error) {
    console.error(\`Unexpected error in createAndQuery:\`, error);
    res.status(500).json(createErrorResponse(error));
  }
}

/**
 * Execute a streaming query in a newly created session
 */
export async function createAndStreamingQuery(req: Request, res: Response) {
  try {
    const { query, sessionName, sessionTags } = req.body as OneshotQueryRequest;

    if (!query) {
      return res.status(400).json({ error: 'Query is required' });
    }

    // Create new session
    const server = req.app.locals.server;
    const sessionId = nanoid();

    // Create session with custom AGIO provider if available
    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

    server.sessions[sessionId] = session;

    // Initialize session
    const { storageUnsubscribe } = await session.initialize();

    // Save unsubscribe function for cleanup
    if (storageUnsubscribe) {
      server.storageUnsubscribes[sessionId] = storageUnsubscribe;
    }

    // Store session metadata if storage is available
    if (server.storageProvider) {
      const metadata: SessionMetadata = {
        id: sessionId,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        name: sessionName,
        workspace: server.getCurrentWorkspace(),
        tags: sessionTags,
      };

      await server.storageProvider.createSession(metadata);
    }

    // Set response headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // Send session ID as the first event
    res.write(
      \`data: \${JSON.stringify({
        type: 'session_created',
        sessionId,
        timestamp: Date.now(),
      })}\\n\\n\`,
    );

    // Get streaming response
    const eventStream = await session.runQueryStreaming(query);

    // Stream events one by one
    for await (const event of eventStream) {
      const isErrorEvent = event.type === 'system' && event.level === 'error';

      // Only send data when connection is still open
      if (!res.closed) {
        res.write(\`data: \${JSON.stringify(event)}\\n\\n\`);

        // If we encounter an error event, end streaming
        if (isErrorEvent) {
          break;
        }
      } else {
        break;
      }
    }

    // End the stream response
    if (!res.closed) {
      res.end();
    }
  } catch (error) {
    console.error(\`Critical error in streaming query creation:\`, error);

    if (!res.headersSent) {
      res.status(500).json(createErrorResponse(error));
    } else {
      const errorObj = createErrorResponse(error);
      res.write(
        \`data: \${JSON.stringify({
          type: 'system',
          level: 'error',
          message: errorObj.error.message,
          timestamp: Date.now(),
        })}\\n\\n\`,
      );
      res.end();
    }
  }
}

--- End of src/api/controllers/oneshot.ts ---

--- File: src/api/controllers/queries.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { createErrorResponse } from '../../utils/error-handler';
import { ContextReferenceProcessor, ImageProcessor } from '@tarko/context-engineer/node';

const imageProcessor = new ImageProcessor({
  quality: 5,
  format: 'webp',
});

const contextReferenceProcessor = new ContextReferenceProcessor({
  maxFileSize: 2 * 1024 * 1024, // 2MB limit for LLM context
  ignoreExtensions: [
    '.jpg',
    '.jpeg',
    '.png',
    '.gif',
    '.webp',
    '.svg',
    '.pdf',
    '.zip',
    '.tar',
    '.gz',
    '.exe',
    '.dll',
  ],
  ignoreDirs: ['node_modules', '.git', '.next', 'dist', 'build', 'coverage', '.vscode', '.idea'],
  maxDepth: 8,
});

/**
 * Execute a non-streaming query
 */
export async function executeQuery(req: Request, res: Response) {
  const { sessionId, query } = req.body;

  if (!query) {
    return res.status(400).json({ error: 'Query is required' });
  }

  try {
    // Get server instance to access workspace path
    const server = req.app.locals.server;
    const workspacePath = server.getCurrentWorkspace();

    // Process contextual references first
    const processedQuery = await contextReferenceProcessor.processContextualReferences(
      query,
      workspacePath,
    );

    // Compress images in processed query
    const compressedQuery = await imageProcessor.compressImagesInQuery(processedQuery);

    // Use enhanced error handling in runQuery
    const response = await req.session!.runQuery(compressedQuery);

    if (response.success) {
      res.status(200).json({ result: response.result });
    } else {
      // Send structured error response with 500 status
      res.status(500).json(response);
    }
  } catch (error) {
    // This should never happen with the new error handling, but just in case
    console.error(\`Unexpected error processing query in session \${sessionId}:\`, error);
    res.status(500).json(createErrorResponse(error));
  }
}

/**
 * Execute a streaming query
 */
export async function executeStreamingQuery(req: Request, res: Response) {
  const { sessionId, query } = req.body;

  if (!query) {
    return res.status(400).json({ error: 'Query is required' });
  }

  try {
    // Set response headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // Get server instance to access workspace path
    const server = req.app.locals.server;
    const workspacePath = server.getCurrentWorkspace();

    // Process contextual references first
    const processedQuery = await contextReferenceProcessor.processContextualReferences(
      query,
      workspacePath,
    );

    // Compress images in processed query
    const compressedQuery = await imageProcessor.compressImagesInQuery(processedQuery);

    // Get streaming response - any errors will be returned as events
    const eventStream = await req.session!.runQueryStreaming(compressedQuery);

    // Stream events one by one
    for await (const event of eventStream) {
      // Check for error events
      const isErrorEvent = event.type === 'system' && event.level === 'error';

      // Only send data when connection is still open
      if (!res.closed) {
        res.write(\`data: \${JSON.stringify(event)}\\n\\n\`);

        // If we encounter an error event, end streaming
        if (isErrorEvent) {
          break;
        }
      } else {
        break;
      }
    }

    // End the stream response
    if (!res.closed) {
      res.end();
    }
  } catch (error) {
    // This should almost never happen with the new error handling
    console.error(\`Critical error in streaming query for session \${sessionId}:\`, error);

    if (!res.headersSent) {
      res.status(500).json(createErrorResponse(error));
    } else {
      const errorObj = createErrorResponse(error);
      res.write(
        \`data: \${JSON.stringify({
          type: 'system',
          level: 'error',
          message: errorObj.error.message,
          timestamp: Date.now(),
        })}\\n\\n\`,
      );
      res.end();
    }
  }
}

/**
 * Abort a running query
 */
export async function abortQuery(req: Request, res: Response) {
  const { sessionId } = req.body;

  try {
    const aborted = req.session!.abortQuery();
    res.status(200).json({ success: aborted });
  } catch (error) {
    console.error(\`Error aborting query in session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to abort query' });
  }
}

--- End of src/api/controllers/queries.ts ---

--- File: src/api/controllers/sessions.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { nanoid } from 'nanoid';
import { SessionMetadata } from '../../storage';
import { AgentSession } from '../../core';
import { ShareService } from '../../services';
import * as path from 'path';
import * as fs from 'fs';

/**
 * Get all sessions
 */
export async function getAllSessions(req: Request, res: Response) {
  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      // If no storage, return only active sessions
      const activeSessions = Object.keys(server.sessions).map((id) => ({
        id,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      }));
      return res.status(200).json({ sessions: activeSessions });
    }

    // Get all sessions from storage
    const sessions = await server.storageProvider.getAllSessions();

    res.status(200).json({ sessions });
  } catch (error) {
    console.error('Failed to get sessions:', error);
    res.status(500).json({ error: 'Failed to get sessions' });
  }
}

/**
 * Create a new session
 */
export async function createSession(req: Request, res: Response) {
  try {
    const server = req.app.locals.server;

    const sessionId = nanoid();

    // Pass custom AGIO provider if available
    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

    server.sessions[sessionId] = session;

    const { storageUnsubscribe } = await session.initialize();

    // Save unsubscribe function for cleanup
    if (storageUnsubscribe) {
      server.storageUnsubscribes[sessionId] = storageUnsubscribe;
    }

    // Store session metadata if we have storage
    if (server.storageProvider) {
      const metadata: SessionMetadata = {
        id: sessionId,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        workspace: server.getCurrentWorkspace(),
      };

      await server.storageProvider.createSession(metadata);
    }

    res.status(201).json({ sessionId });
  } catch (error) {
    console.error('Failed to create session:', error);
    res.status(500).json({ error: 'Failed to create session' });
  }
}

/**
 * Get session details
 */
export async function getSessionDetails(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    // Check storage first
    if (server.storageProvider) {
      const metadata = await server.storageProvider.getSessionMetadata(sessionId);
      if (metadata) {
        return res.status(200).json({
          session: metadata,
        });
      }
    }

    return res.status(404).json({ error: 'Session not found' });
  } catch (error) {
    console.error(\`Error getting session details for \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to get session details' });
  }
}

/**
 * Get session events
 */
export async function getSessionEvents(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      return res.status(404).json({ error: 'Storage not configured, no events available' });
    }

    const events = await server.storageProvider.getSessionEvents(sessionId);
    res.status(200).json({ events });
  } catch (error) {
    console.error(\`Error getting events for session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to get session events' });
  }
}

/**
 * Get session status
 */
export async function getSessionStatus(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const session = req.session as AgentSession;

    const isProcessing = session.getProcessingStatus();

    res.status(200).json({
      sessionId,
      status: {
        isProcessing,
        state: session.agent.status(),
      },
    });
  } catch (error) {
    console.error(\`Error getting session status (\${sessionId}):\`, error);
    res.status(500).json({ error: 'Failed to get session status' });
  }
}

/**
 * Update session metadata
 */
export async function updateSession(req: Request, res: Response) {
  const { sessionId, name, tags } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      return res.status(404).json({ error: 'Storage not configured, cannot update session' });
    }

    const metadata = await server.storageProvider.getSessionMetadata(sessionId);
    if (!metadata) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {
      name,
      tags,
      updatedAt: Date.now(),
    });

    res.status(200).json({ session: updatedMetadata });
  } catch (error) {
    console.error(\`Error updating session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to update session' });
  }
}

/**
 * Delete a session
 */
export async function deleteSession(req: Request, res: Response) {
  const { sessionId } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    // Close active session if exists
    if (server.sessions[sessionId]) {
      // Before clearing the session, try dispose the agent first
      try {
        const agent = server.sessions[sessionId].agent;
        if (agent) {
          agent.dispose();
        }
      } catch (error) {
        console.warn(
          \`Failed to cleanup agent for session \${sessionId}: \${error instanceof Error ? error.message : String(error)}\`,
        );
      }

      await server.sessions[sessionId].cleanup();
      delete server.sessions[sessionId];

      // Clean up storage unsubscribe
      if (server.storageUnsubscribes[sessionId]) {
        server.storageUnsubscribes[sessionId]();
        delete server.storageUnsubscribes[sessionId];
      }
    }

    // Delete from storage if configured
    if (server.storageProvider) {
      const deleted = await server.storageProvider.deleteSession(sessionId);
      if (!deleted) {
        return res.status(404).json({ error: 'Session not found in storage' });
      }
    }

    res.status(200).json({ success: true });
  } catch (error) {
    console.error(\`Error deleting session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to delete session' });
  }
}

/**
 * Generate summary for a session
 */
export async function generateSummary(req: Request, res: Response) {
  const { sessionId, messages, model, provider } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  if (!Array.isArray(messages) || messages.length === 0) {
    return res.status(400).json({ error: 'Messages are required' });
  }

  try {
    const server = req.app.locals.server;
    const session = server.sessions[sessionId];

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // FIXME: Use smaller messages to generate summaries
    // Generate summary using the agent's method
    const summaryResponse = await session.agent.generateSummary({
      messages,
      model,
      provider,
    });

    // Return the summary
    res.status(200).json(summaryResponse);
  } catch (error) {
    console.error(\`Error generating summary for session \${sessionId}:\`, error);
    res.status(500).json({
      error: 'Failed to generate summary',
      message: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Share a session
 */
export async function shareSession(req: Request, res: Response) {
  const { sessionId, upload } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;
    const shareService = new ShareService(server.appConfig, server.storageProvider);

    // Get agent instance if session is active (for slug generation)
    const agent = server.sessions[sessionId]?.agent;
    const result = await shareService.shareSession(sessionId, upload, agent, server.versionInfo);
    if (result.success) {
      return res.status(200).json(result);
    } else {
      return res.status(500).json({
        error: result.error || 'Failed to share session',
      });
    }
  } catch (error) {
    console.error(\`Error sharing session \${sessionId}:\`, error);
    return res.status(500).json({ error: 'Failed to share session' });
  }
}

/**
 * Get events from the latest updated session
 */
export async function getLatestSessionEvents(req: Request, res: Response) {
  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      return res
        .status(404)
        .json({ error: 'Storage not configured, cannot get latest session events' });
    }

    // Get all sessions
    const sessions = await server.storageProvider.getAllSessions();

    if (sessions.length === 0) {
      return res.status(404).json({ error: 'No sessions found' });
    }

    // Find the session with the most recent updatedAt timestamp
    const latestSession = sessions.reduce((latest, current) => {
      return current.updatedAt > latest.updatedAt ? current : latest;
    });

    // Get events for the latest session
    const events = await server.storageProvider.getSessionEvents(latestSession.id);

    res.status(200).json({
      sessionId: latestSession.id,
      sessionMetadata: latestSession,
      events,
    });
  } catch (error) {
    console.error('Error getting latest session events:', error);
    res.status(500).json({ error: 'Failed to get latest session events' });
  }
}

/**
 * Get session workspace files
 */
export async function getSessionWorkspaceFiles(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;
  const requestPath = (req.query.path as string) || '/';

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;
    const session = server.sessions[sessionId];

    // Check if session exists (active or stored)
    if (!session && server.storageProvider) {
      const metadata = await server.storageProvider.getSessionMetadata(sessionId);
      if (!metadata) {
        return res.status(404).json({ error: 'Session not found' });
      }
    } else if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const baseWorkspacePath = server.getCurrentWorkspace();

    // Build potential file paths
    const pathsToCheck: string[] = [];

    pathsToCheck.push(path.join(baseWorkspacePath, requestPath));

    // Find the first existing path
    let targetPath: string | null = null;
    for (const checkPath of pathsToCheck) {
      const normalizedPath = path.resolve(checkPath);
      const normalizedWorkspace = path.resolve(baseWorkspacePath);

      // Security check
      if (normalizedPath.startsWith(normalizedWorkspace) && fs.existsSync(normalizedPath)) {
        targetPath = normalizedPath;
        break;
      }
    }

    if (!targetPath) {
      return res.status(404).json({ error: 'Path not found' });
    }

    const stats = fs.statSync(targetPath);

    if (stats.isFile()) {
      // Return file info
      return res.json({
        type: 'file',
        name: path.basename(targetPath),
        size: stats.size,
        modified: stats.mtime,
        path: requestPath,
      });
    } else if (stats.isDirectory()) {
      // Return directory listing
      const files = fs.readdirSync(targetPath).map((file) => {
        const filePath = path.join(targetPath, file);
        const fileStats = fs.statSync(filePath);
        return {
          name: file,
          isDirectory: fileStats.isDirectory(),
          size: fileStats.size,
          modified: fileStats.mtime,
          path: path.join(requestPath, file).replace(/\\\\/g, '/'),
        };
      });

      return res.json({
        type: 'directory',
        path: requestPath,
        files: files.sort((a, b) => {
          if (a.isDirectory && !b.isDirectory) return -1;
          if (!a.isDirectory && b.isDirectory) return 1;
          return a.name.localeCompare(b.name);
        }),
      });
    }

    return res.status(400).json({ error: 'Invalid path type' });
  } catch (error) {
    console.error(\`Error accessing workspace files for session \${sessionId}:\`, error);
    res.status(500).json({
      error: 'Failed to access workspace files',
      message: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Search files and directories in session workspace
 */
export async function searchWorkspaceItems(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;
  const query = req.query.q as string;
  const type = req.query.type as 'file' | 'directory' | 'all';

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  // Allow empty query for default directory listing
  if (query === undefined || query === null) {
    return res.status(400).json({ error: 'Search query parameter is required' });
  }

  try {
    const server = req.app.locals.server;
    const baseWorkspacePath = server.getCurrentWorkspace();

    let items: Array<{ name: string; path: string; type: 'file' | 'directory'; relativePath: string }>;

    if (query.length === 0) {
      // Empty query: return current directory contents (top-level files and directories)
      items = await getWorkspaceRootItems(baseWorkspacePath, type || 'all');
    } else {
      // Non-empty query: search recursively
      items = await searchWorkspaceItemsRecursive(baseWorkspacePath, query, type || 'all');
    }

    // Limit results to avoid overwhelming the UI
    const limitedItems = items.slice(0, 20);

    res.status(200).json({ items: limitedItems });
  } catch (error) {
    console.error(\`Error searching workspace items for session \${sessionId}:\`, error);
    res.status(500).json({
      error: 'Failed to search workspace items',
      message: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Recursively search for files and directories
 */
async function searchWorkspaceItemsRecursive(
  basePath: string,
  query: string,
  type: 'file' | 'directory' | 'all',
): Promise<
  Array<{ name: string; path: string; type: 'file' | 'directory'; relativePath: string }>
> {
  const items: Array<{
    name: string;
    path: string;
    type: 'file' | 'directory';
    relativePath: string;
  }> = [];

  const searchInDirectory = async (currentPath: string, depth = 0) => {
    // Limit recursion depth to avoid performance issues
    if (depth > 5) return;

    try {
      const entries = fs.readdirSync(currentPath);

      for (const entry of entries) {
        // Skip hidden files and common ignore patterns
        if (entry.startsWith('.') || entry === 'node_modules' || entry === '.git') {
          continue;
        }

        const fullPath = path.join(currentPath, entry);
        const stats = fs.statSync(fullPath);
        const relativePath = path.relative(basePath, fullPath);

        // Check if name matches query (case-insensitive)
        if (entry.toLowerCase().includes(query.toLowerCase())) {
          const itemType = stats.isDirectory() ? 'directory' : 'file';

          if (type === 'all' || type === itemType) {
            items.push({
              name: entry,
              path: fullPath,
              type: itemType,
              relativePath: relativePath.replace(/\\\\/g, '/'), // Normalize path separators
            });
          }
        }

        // Recursively search in subdirectories
        if (stats.isDirectory()) {
          await searchInDirectory(fullPath, depth + 1);
        }
      }
    } catch (error) {
      // Skip directories we can't read
      console.warn(\`Cannot read directory \${currentPath}:\`, error);
    }
  };

  await searchInDirectory(basePath);

  // Sort by type (directories first) then by name
  return items.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type === 'directory' ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });
}

/**
 * Get root level items in workspace
 */
async function getWorkspaceRootItems(
  basePath: string,
  type: 'file' | 'directory' | 'all',
): Promise<Array<{ name: string; path: string; type: 'file' | 'directory'; relativePath: string }>> {
  const items: Array<{
    name: string;
    path: string;
    type: 'file' | 'directory';
    relativePath: string;
  }> = [];

  try {
    const entries = fs.readdirSync(basePath);

    for (const entry of entries) {
      // Skip hidden files and common ignore patterns
      if (entry.startsWith('.') || entry === 'node_modules' || entry === '.git') {
        continue;
      }

      const fullPath = path.join(basePath, entry);
      const stats = fs.statSync(fullPath);
      const itemType = stats.isDirectory() ? 'directory' : 'file';

      if (type === 'all' || type === itemType) {
        items.push({
          name: entry,
          path: fullPath,
          type: itemType,
          relativePath: entry,
        });
      }
    }
  } catch (error) {
    console.warn(\`Cannot read directory \${basePath}:\`, error);
  }

  // Sort by type (directories first) then by name
  return items.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type === 'directory' ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });
}
--- End of src/api/controllers/sessions.ts ---

--- File: src/api/controllers/share.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { ShareService } from '../../services';

/**
 * Get share configuration
 */
export function getShareConfig(req: Request, res: Response) {
  const server = req.app.locals.server;
  const shareService = new ShareService(server.appConfig, server.storageProvider);
  res.status(200).json(shareService.getShareConfig());
}

--- End of src/api/controllers/share.ts ---

--- File: src/api/controllers/system.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';

/**
 * Health check endpoint
 */
export function healthCheck(req: Request, res: Response) {
  res.status(200).json({ status: 'ok' });
}

/**
 * Get version information including git hash
 */
export function getVersion(req: Request, res: Response) {
  const server = req.app.locals.server;
  res.status(200).json({
    version: server.versionInfo?.version,
    buildTime: server.versionInfo?.buildTime,
    gitHash: server.versionInfo?.gitHash,
  });
}

/**
 * Get current agent information
 */
export function getAgentInfo(req: Request, res: Response) {
  const server = req.app.locals.server;
  res.status(200).json({
    name: server.getCurrentAgentName() || 'Unknown Agent',
  });
}

--- End of src/api/controllers/system.ts ---
=== End of Directory: src/api/controllers ===

=== Directory: src/api/middleware ===

--- File: src/api/middleware/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export { sessionRestoreMiddleware } from './session-restore';

--- End of src/api/middleware/index.ts ---

--- File: src/api/middleware/session-restore.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@tarko/shared-utils';
import { AgentServer } from '../../server';
import { AgentSession } from '../../core';

const logger = getLogger('SessionRestoreMiddleware');
/**
 * Session recovery middleware
 * If the session is not in memory but the storage is available, try to restore the session from storage
 */
export async function sessionRestoreMiddleware(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void | Response> {
  const server: AgentServer = req.app.locals.server;

  try {
    const sessionId = (req.query.sessionId as string) || (req.body.sessionId as string);

    if (!sessionId) {
      return res.status(400).json({ error: 'Session ID is required' });
    }

    let session = server.sessions[sessionId];

    // If the session is not in memory but the storage is available, try to restore the session from storage
    if (!session && server.storageProvider) {
      const metadata = await server.storageProvider.getSessionMetadata(sessionId);
      if (metadata) {
        try {
          // Recover sessions from storage using a custom AGIO provider
          session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

          server.sessions[sessionId] = session;

          const { storageUnsubscribe } = await session.initialize();

          // Save unsubscribe function for cleaning
          if (storageUnsubscribe) {
            server.storageUnsubscribes[sessionId] = storageUnsubscribe;
          }

          logger.debug(\`Session \${sessionId} restored from storage\`);
        } catch (error) {
          logger.error(\`Failed to restore session \${sessionId}:\`, error);

          return res.status(200).json({
            sessionId,
            status: {
              isProcessing: false,
              state: 'stored', //Special state, indicating that the session exists in storage but is not activated
            },
          });
        }
      }
    }

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // Mounted on req for subsequent reading
    req.session = session;

    next();
  } catch (error) {
    logger.error(\`Session restore middleware error: \${(error as Error).message}\`);
    return res.status(500).json({ error: \`Internal server error, \${(error as Error).message}\` });
  }
}

--- End of src/api/middleware/session-restore.ts ---
=== End of Directory: src/api/middleware ===

=== Directory: src/api/routes ===

--- File: src/api/routes/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import { registerSessionRoutes } from './sessions';
import { registerQueryRoutes } from './queries';
import { registerSystemRoutes } from './system';
import { registerShareRoutes } from './share';
import { registerOneshotRoutes } from './oneshot';

/**
 * Register all API routes with the Express application
 * @param app Express application
 */
export function registerAllRoutes(app: express.Application): void {
  registerSessionRoutes(app);
  registerQueryRoutes(app);
  registerSystemRoutes(app);
  registerShareRoutes(app);
  registerOneshotRoutes(app);
}

--- End of src/api/routes/index.ts ---

--- File: src/api/routes/oneshot.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as oneshotController from '../controllers/oneshot';

/**
 * Register one-shot query routes (create session and execute query in one step)
 * @param app Express application
 */
export function registerOneshotRoutes(app: express.Application): void {
  // Create session and send a query (non-streaming)
  app.post('/api/v1/oneshot/query', oneshotController.createAndQuery);

  // Create session and send a streaming query
  app.post('/api/v1/oneshot/query/stream', oneshotController.createAndStreamingQuery);
}

--- End of src/api/routes/oneshot.ts ---

--- File: src/api/routes/queries.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as queriesController from '../controllers/queries';
import { sessionRestoreMiddleware } from '../middleware';

/**
 * Register query execution routes
 * @param app Express application
 */
export function registerQueryRoutes(app: express.Application): void {
  app.group('/api/v1/sessions', [sessionRestoreMiddleware], (router: express.Router) => {
    // Send a query (non-streaming)
    router.post('/query', queriesController.executeQuery);
    // Send a streaming query
    router.post('/query/stream', queriesController.executeStreamingQuery);
    // Abort a running query
    router.post('/abort', queriesController.abortQuery);
  });
}

--- End of src/api/routes/queries.ts ---

--- File: src/api/routes/sessions.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as sessionsController from '../controllers/sessions';
import { sessionRestoreMiddleware } from '../middleware';

/**
 * Register session management routes
 * @param app Express application
 */
export function registerSessionRoutes(app: express.Application): void {
  app.group('/api/v1/sessions', (router: express.Router) => {
    // Get all sessions
    router.get('/', sessionsController.getAllSessions);
    // Create a new session
    router.post('/create', sessionsController.createSession);
  });

  app.group('/api/v1/sessions', [sessionRestoreMiddleware], (router: express.Router) => {
    // Get session details
    router.get('/details', sessionsController.getSessionDetails);
    // Get session events
    router.get('/events', sessionsController.getSessionEvents);
    // Get latest session events
    router.get('/events/latest', sessionsController.getLatestSessionEvents);
    // Get session status
    router.get('/status', sessionsController.getSessionStatus);
    // Update session metadata
    router.post('/update', sessionsController.updateSession);
    // Delete a session
    router.post('/delete', sessionsController.deleteSession);
    // Generate summary for a session
    router.post('/generate-summary', sessionsController.generateSummary);
    // Share a session
    router.post('/share', sessionsController.shareSession);
    // Get session workspace files
    router.get('/workspace/files', sessionsController.getSessionWorkspaceFiles);
    // Search workspace items for contextual selector
    router.get('/workspace/search', sessionsController.searchWorkspaceItems);
  });
}
--- End of src/api/routes/sessions.ts ---

--- File: src/api/routes/share.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as shareController from '../controllers/share';

/**
 * Register sharing-related routes
 * @param app Express application
 */
export function registerShareRoutes(app: express.Application): void {
  // Get share configuration
  app.get('/api/v1/share/config', shareController.getShareConfig);
}

--- End of src/api/routes/share.ts ---

--- File: src/api/routes/system.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as systemController from '../controllers/system';

/**
 * Register system information routes
 * @param app Express application
 */
export function registerSystemRoutes(app: express.Application): void {
  // Health check endpoint
  app.get('/api/v1/health', systemController.healthCheck);

  // Version information endpoint
  app.get('/api/v1/version', systemController.getVersion);

  // Agent information endpoint
  app.get('/api/v1/agent', systemController.getAgentInfo);
}

--- End of src/api/routes/system.ts ---
=== End of Directory: src/api/routes ===

=== Directory: src/core ===

--- File: src/core/AgentSession.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import path from 'path';
import {
  AgentEventStream,
  AgentStatus,
  AgioProviderConstructor,
  ChatCompletionContentPart,
  IAgent,
} from '@tarko/interface';
import { AgentSnapshot } from '@tarko/agent-snapshot';
import { EventStreamBridge } from '../utils/event-stream';
import type { AgentServer } from '../server';
import { AgioEvent } from '@tarko/agio';
import { handleAgentError, ErrorWithCode } from '../utils/error-handler';

/**
 * Check if an event should be stored in persistent storage
 * Filters out streaming events that are only needed for real-time updates
 * but not for replay/sharing functionality
 */
function shouldStoreEvent(event: AgentEventStream.Event): boolean {
  // Filter out streaming events that cause performance issues during replay
  const streamingEventTypes: AgentEventStream.EventType[] = [
    'assistant_streaming_message',
    'assistant_streaming_thinking_message',
    'assistant_streaming_tool_call',
    'final_answer_streaming',
  ];

  return !streamingEventTypes.includes(event.type);
}

/**
 * Response type for agent query execution
 */
export interface AgentQueryResponse<T = any> {
  success: boolean;
  result?: T;
  error?: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
}

/**
 * AgentSession - Represents a single agent execution context
 *
 * Responsible for:
 * - Managing a generic Agent instance and its lifecycle
 * - Connecting agent events to clients via EventStreamBridge
 * - Handling queries and interactions with the agent
 * - Persisting events to storage
 * - Collecting AGIO monitoring events if configured
 */
export class AgentSession {
  id: string;
  agent: IAgent;
  eventBridge: EventStreamBridge;
  private unsubscribe: (() => void) | null = null;
  private agioProvider?: AgioEvent.AgioProvider;

  constructor(
    private server: AgentServer,
    sessionId: string,
    agioProviderImpl?: AgioProviderConstructor,
  ) {
    this.id = sessionId;
    this.eventBridge = new EventStreamBridge();

    // Get agent options from server
    const agentOptions = { ...server.appConfig };

    // Create agent instance using the server's factory method
    const agent = server.createAgent();

    // Initialize agent snapshot if enabled
    if (agentOptions.snapshot?.enable) {
      const snapshotStoragesDirectory =
        agentOptions.snapshot.storageDirectory ?? server.getCurrentWorkspace();

      if (snapshotStoragesDirectory) {
        const snapshotPath = path.join(snapshotStoragesDirectory, sessionId);
        // @ts-expect-error
        this.agent = new AgentSnapshot(agent, {
          snapshotPath,
          snapshotName: sessionId,
        }) as unknown as IAgent;

        // Log snapshot initialization if agent has logger
        if ('logger' in agent) {
          (agent as any).logger.debug(\`AgentSnapshot initialized with path: \${snapshotPath}\`);
        }
      } else {
        this.agent = agent;
      }
    } else {
      this.agent = agent;
    }

    // Initialize AGIO collector if provider URL is configured
    if (agentOptions.agio?.provider && agioProviderImpl) {
      const impl = agioProviderImpl;
      this.agioProvider = new impl(agentOptions.agio.provider, agentOptions, sessionId, this.agent);

      // Log AGIO initialization if agent has logger
      if ('logger' in this.agent) {
        (this.agent as any).logger.debug(
          \`AGIO collector initialized with provider: \${agentOptions.agio.provider}\`,
        );
      }
    }

    // Log agent configuration if agent has logger and getOptions method
    if ('logger' in this.agent && 'getOptions' in this.agent) {
      (this.agent as any).logger.info(
        'Agent Config',
        JSON.stringify((this.agent as any).getOptions(), null, 2),
      );
    }
  }

  /**
   * Get the current processing status of the agent
   * @returns Whether the agent is currently processing a request
   */
  getProcessingStatus(): boolean {
    return this.agent.status() === AgentStatus.EXECUTING;
  }

  async initialize() {
    await this.agent.initialize();

    // Send agent initialization event to AGIO if configured
    if (this.agioProvider) {
      try {
        await this.agioProvider.sendAgentInitialized();
      } catch (error) {
        console.error('Failed to send AGIO initialization event:', error);
      }
    }

    // Connect to agent's event stream manager
    const agentEventStream = this.agent.getEventStream();

    // Create an event handler that saves events to storage and processes AGIO events
    const handleEvent = async (event: AgentEventStream.Event) => {
      // If we have storage, save the event (filtered for performance)
      if (this.server.storageProvider && shouldStoreEvent(event)) {
        try {
          await this.server.storageProvider.saveEvent(this.id, event);
        } catch (error) {
          console.error(\`Failed to save event to storage: \${error}\`);
        }
      }

      // Process AGIO events if collector is configured
      if (this.agioProvider) {
        try {
          await this.agioProvider.processAgentEvent(event);
        } catch (error) {
          console.error('Failed to process AGIO event:', error);
        }
      }
    };

    // Subscribe to events for storage and AGIO processing
    const storageUnsubscribe = agentEventStream.subscribe(handleEvent);

    // Connect to event bridge for client communication
    this.unsubscribe = this.eventBridge.connectToAgentEventStream(agentEventStream);

    // Notify client that session is ready
    this.eventBridge.emit('ready', { sessionId: this.id });

    return { storageUnsubscribe };
  }

  /**
   * Run a query and return a strongly-typed response
   * This version captures errors and returns structured response objects
   * @param query The query to process
   * @returns Structured response with success/error information
   */
  async runQuery(query: string | ChatCompletionContentPart[]): Promise<AgentQueryResponse> {
    try {
      // Run agent to process the query
      const result = await this.agent.run({
        input: query,
      });
      return {
        success: true,
        result,
      };
    } catch (error) {
      // Emit error event but don't throw
      this.eventBridge.emit('error', {
        message: error instanceof Error ? error.message : String(error),
      });

      // Handle error and return structured response
      const handledError = handleAgentError(error, \`Session \${this.id}\`);

      return {
        success: false,
        error: {
          code: handledError.code,
          message: handledError.message,
          details: handledError.details,
        },
      };
    }
  }

  /**
   * Execute a streaming query with robust error handling
   * @param query The query to process in streaming mode
   * @returns AsyncIterable of events or error response
   */
  async runQueryStreaming(
    query: string | ChatCompletionContentPart[],
  ): Promise<AsyncIterable<AgentEventStream.Event>> {
    try {
      // Run agent in streaming mode
      return await this.agent.run({
        input: query,
        stream: true,
      });
    } catch (error) {
      // Emit error event
      this.eventBridge.emit('error', {
        message: error instanceof Error ? error.message : String(error),
      });

      // Handle error and return a synthetic event stream with the error
      const handledError = handleAgentError(error, \`Session \${this.id} (streaming)\`);

      // Create a synthetic event stream that yields just an error event
      return this.createErrorEventStream(handledError);
    }
  }

  /**
   * Create a synthetic event stream containing an error event
   * This allows streaming endpoints to handle errors gracefully
   */
  private async *createErrorEventStream(
    error: ErrorWithCode,
  ): AsyncIterable<AgentEventStream.Event> {
    yield this.agent.getEventStream().createEvent('system', {
      level: 'error',
      message: error.message,
      details: {
        errorCode: error.code,
        details: error.details,
      },
    });
  }

  /**
   * Abort the currently running query
   * @returns True if the agent was running and aborted successfully
   */
  async abortQuery(): Promise<boolean> {
    try {
      const aborted = this.agent.abort();
      if (aborted) {
        this.eventBridge.emit('aborted', { sessionId: this.id });
      }
      return aborted;
    } catch (error) {
      this.eventBridge.emit('error', {
        message: error instanceof Error ? error.message : String(error),
      });
      return false;
    }
  }

  async cleanup() {
    // Unsubscribe from event stream
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }

    // Clean up agent resources
    await this.agent.dispose();

    if (this.agioProvider) {
      // This ensures that all buffered analytics events are sent before the session is terminated.
      await this.agioProvider.cleanup?.();
    }

    this.eventBridge.emit('closed', { sessionId: this.id });
  }
}

export default AgentSession;

--- End of src/core/AgentSession.ts ---

--- File: src/core/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './AgentSession';
export * from './SocketHandlers';

--- End of src/core/index.ts ---

--- File: src/core/SocketHandlers.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Socket } from 'socket.io';
import { Server as SocketIOServer } from 'socket.io';
import http from 'http';
import { AgentServer } from '../server';
import { handleAgentError } from '../utils/error-handler';

/**
 * Setup WebSocket functionality for the server
 * @param httpServer HTTP server instance
 * @param server AgentServer instance
 * @returns Configured Socket.IO server
 */
export function setupSocketIO(httpServer: http.Server, server: AgentServer): SocketIOServer {
  const io = new SocketIOServer(httpServer, {
    cors: {
      origin: '*',
      methods: ['GET', 'POST'],
    },
  });

  // Register connection handler
  io.on('connection', (socket) => {
    SocketHandlers.handleConnection(socket, server);
  });

  return io;
}

/**
 * SocketHandlers - Event handlers for WebSocket connections
 *
 * Manages all socket events including:
 * - Connection/disconnection
 * - Session joining
 * - Query sending
 * - Query aborting
 */
export class SocketHandlers {
  /**
   * Handle client connection
   */
  static handleConnection(socket: Socket, server: AgentServer) {
    console.log('Client connected:', socket.id);

    // Register event handlers
    socket.on('ping', (callback) => {
      if (typeof callback === 'function') {
        callback();
      }
    });

    socket.on('join-session', (sessionId) => {
      SocketHandlers.handleJoinSession(socket, server, sessionId);
    });

    socket.on('send-query', async ({ sessionId, query }) => {
      await SocketHandlers.handleSendQuery(socket, server, sessionId, query);
    });

    socket.on('abort-query', async ({ sessionId }) => {
      await SocketHandlers.handleAbortQuery(socket, server, sessionId);
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
    });
  }

  /**
   * Handle session joining
   */
  static handleJoinSession(socket: Socket, server: AgentServer, sessionId: string) {
    if (server.sessions[sessionId]) {
      socket.join(sessionId);
      console.log(\`Client \${socket.id} joined session \${sessionId}\`);

      // Subscribe to session's event stream
      const eventHandler = (eventType: string, data: any) => {
        socket.emit('agent-event', { type: eventType, data });
      };

      // Send initial status update immediately after joining
      const initialStatus = {
        isProcessing: server.sessions[sessionId].getProcessingStatus(),
        state: server.sessions[sessionId].agent.status(),
      };
      socket.emit('agent-status', initialStatus);

      server.sessions[sessionId].eventBridge.subscribe(eventHandler);

      socket.on('disconnect', () => {
        if (server.sessions[sessionId]) {
          server.sessions[sessionId].eventBridge.unsubscribe(eventHandler);
        }
      });
    } else {
      socket.emit('error', 'Session not found');
    }
  }

  /**
   * Handle sending a query
   */
  static async handleSendQuery(
    socket: Socket,
    server: AgentServer,
    sessionId: string,
    query: string,
  ) {
    if (server.sessions[sessionId]) {
      try {
        // Use enhanced error handling in runQuery
        const response = await server.sessions[sessionId].runQuery(query);

        if (!response.success && response.error) {
          socket.emit('error', response.error.message);
        }
      } catch (error) {
        // This should never happen with the new error handling
        const handledError = handleAgentError(error);
        console.error('Unexpected error in socket query:', handledError);
        socket.emit('error', handledError.message);
      }
    } else {
      socket.emit('error', 'Session not found');
    }
  }

  /**
   * Handle aborting a query
   */
  static async handleAbortQuery(socket: Socket, server: AgentServer, sessionId: string) {
    if (server.sessions[sessionId]) {
      try {
        const aborted = await server.sessions[sessionId].abortQuery();
        socket.emit('abort-result', { success: aborted });
      } catch (error) {
        console.error('Error aborting query:', error);
        socket.emit('error', 'Failed to abort query');
      }
    } else {
      socket.emit('error', 'Session not found');
    }
  }
}

--- End of src/core/SocketHandlers.ts ---
=== End of Directory: src/core ===

=== Directory: src/services ===

--- File: src/services/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './ShareService';

--- End of src/services/index.ts ---

--- File: src/services/ShareService.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import crypto from 'crypto';
import { AgentEventStream, isAgentWebUIImplementationType } from '@tarko/interface';
import { SessionMetadata, StorageProvider } from '../storage';
import { ShareUtils } from '../utils/share';
import { SlugGenerator } from '../utils/slug-generator';
import fs from 'fs';
import path from 'path';
import { ensureHttps } from '../utils';
import type { AgentServerVersionInfo, IAgent, AgentAppConfig } from '../types';

/**
 * ShareService - Centralized service for handling session sharing
 *
 * Responsible for:
 * - Generating shareable HTML content
 * - Uploading shared content to providers
 * - Managing share metadata and slugs
 * - Processing and uploading workspace images
 */
export class ShareService {
  constructor(
    private appConfig: AgentAppConfig,
    private storageProvider: StorageProvider | null,
  ) {}

  /**
   * Share a session
   * @param sessionId Session ID to share
   * @param upload Whether to upload to share provider
   * @param agent Optional agent instance for slug generation
   * @param serverInfo Optional server version info
   * @returns Share result with URL or HTML content
   */
  async shareSession(
    sessionId: string,
    upload = false,
    agent?: IAgent,
    serverInfo?: AgentServerVersionInfo,
  ): Promise<{
    success: boolean;
    url?: string;
    html?: string;
    sessionId: string;
    error?: string;
  }> {
    try {
      // Verify storage is available
      if (!this.storageProvider) {
        throw new Error('Storage not configured, cannot share session');
      }

      // Get session metadata
      const metadata = await this.storageProvider.getSessionMetadata(sessionId);
      if (!metadata) {
        throw new Error('Session not found');
      }

      // Get session events
      const events = await this.storageProvider.getSessionEvents(sessionId);

      // Filter key frame events, exclude streaming messages
      const keyFrameEvents = events.filter(
        (event) =>
          event.type !== 'assistant_streaming_message' &&
          event.type !== 'assistant_streaming_thinking_message' &&
          event.type !== 'final_answer_streaming',
      );

      // Generate HTML content with server options
      let processedEvents = keyFrameEvents;
      if (upload && this.appConfig.share?.provider) {
        // @ts-expect-error
        processedEvents = await this.processWorkspaceImages(keyFrameEvents, metadata.workspace);
      }

      // Generate HTML content
      const shareHtml = this.generateShareHtml(keyFrameEvents, metadata, serverInfo);

      // Upload if requested and provider is configured
      if (upload && this.appConfig.share?.provider) {
        const shareUrl = await this.uploadShareHtml(shareHtml, sessionId, metadata, agent);
        return {
          success: true,
          url: shareUrl,
          sessionId,
        };
      }

      // Return HTML content if not uploading
      return {
        success: true,
        html: shareHtml,
        sessionId,
      };
    } catch (error) {
      return {
        success: false,
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Process workspace images in events and replace relative paths with uploaded URLs
   */
  private async processWorkspaceImages(
    events: AgentEventStream.Event[],
    workspace: string,
  ): Promise<AgentEventStream.Event[]> {
    if (!this.appConfig.share?.provider) {
      return events;
    }

    const processedEvents = [...events];
    const imageCache = new Map<string, string>(); // Cache to avoid duplicate uploads

    for (let i = 0; i < processedEvents.length; i++) {
      const event = processedEvents[i];

      // Process different event types that might contain file references
      if (event.type === 'tool_call' && event.name === 'write_file') {
        // Check write_file tool results for image references
        processedEvents[i] = await this.processEventImages(event, workspace, imageCache);
      }
    }

    return processedEvents;
  }

  /**
   * Process images in a single event
   */
  private async processEventImages(
    event: AgentEventStream.Event,
    workspace: string,
    imageCache: Map<string, string>,
  ): Promise<AgentEventStream.Event> {
    console.log('processEventImages');

    let content = '';

    // Extract content based on event type
    if (event.type === 'tool_call' && event.name === 'write_file') {
      content = event.arguments.content;
    } else {
      return event; // No processable content
    }

    // Find relative image paths in content
    const imageMatches = this.findImageReferences(content);
    if (imageMatches.length === 0) {
      return event;
    }

    let processedContent = content;

    // Process each image reference
    for (const match of imageMatches) {
      const { fullMatch, relativePath } = match;

      // Skip if already cached
      if (imageCache.has(relativePath)) {
        const uploadedUrl = imageCache.get(relativePath)!;
        processedContent = processedContent.replace(
          fullMatch,
          fullMatch.replace(relativePath, uploadedUrl),
        );
        continue;
      }

      try {
        // Resolve absolute path
        const absolutePath = path.resolve(workspace, relativePath);

        // Check if file exists and is an image
        if (fs.existsSync(absolutePath) && this.isImageFile(absolutePath)) {
          // Upload the image
          const uploadedUrl = await this.uploadWorkspaceImage(absolutePath, relativePath);

          // Cache the result
          imageCache.set(relativePath, uploadedUrl);

          // Replace in content
          processedContent = processedContent.replace(
            fullMatch,
            fullMatch.replace(relativePath, uploadedUrl),
          );
        }
      } catch (error) {
        console.warn(\`Failed to upload workspace image \${relativePath}:\`, error);
        // Continue with original path if upload fails
      }
    }

    // Return updated event
    const updatedEvent = { ...event };
    if (event.type === 'tool_call' && event.name === 'write_file') {
      updatedEvent.arguments.content = processedContent;
    }

    return updatedEvent;
  }

  /**
   * Find image references in content
   */
  private findImageReferences(content: string): Array<{ fullMatch: string; relativePath: string }> {
    const imageReferences: Array<{ fullMatch: string; relativePath: string }> = [];

    // Patterns to match relative image paths
    const patterns = [
      // Markdown images: ![alt](./path/to/image.jpg)
      /!\\[([^\\]]*)\\]\\(\\.\\/([^)]+\\.(jpg|jpeg|png|gif|webp|svg))\\)/gi,
      /!\\[([^\\]]*)\\]\\(([^\\/][^)]+\\.(jpg|jpeg|png|gif|webp|svg))\\)/gi,
      // HTML img tags: <img src="./path/to/image.jpg">
      /<img[^>]+src=["']\\.\\/([^"']+\\.(jpg|jpeg|png|gif|webp|svg))["'][^>]*>/gi,
      /<img[^>]+src=["']([^\\/][^"']+\\.(jpg|jpeg|png|gif|webp|svg))["'][^>]*>/gi,
      // Direct file references in code blocks or text
      /(?:^|\\s)(\\.\\/[^\\s]+\\.(jpg|jpeg|png|gif|webp|svg))(?:\\s|$)/gi,
      /(?:^|\\s)([^\\/\\s][^\\s]*\\.(jpg|jpeg|png|gif|webp|svg))(?:\\s|$)/gi,
    ];

    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const fullMatch = match[0];
        // Extract the relative path from different capture groups based on pattern
        let relativePath = '';

        if (match[2] && match[2].includes('.')) {
          // For patterns with capture group 2 containing the path
          relativePath = match[2];
        } else if (match[1] && match[1].includes('.')) {
          // For patterns with capture group 1 containing the path
          relativePath = match[1];
        }

        if (relativePath && !relativePath.startsWith('http') && !relativePath.startsWith('data:')) {
          // Normalize relative path
          if (relativePath.startsWith('./')) {
            relativePath = relativePath.slice(2);
          }

          imageReferences.push({
            fullMatch,
            relativePath,
          });
        }
      }
    }

    return imageReferences;
  }

  /**
   * Check if file is an image based on extension
   */
  private isImageFile(filePath: string): boolean {
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    const ext = path.extname(filePath).toLowerCase();
    return imageExtensions.includes(ext);
  }

  /**
   * Upload a workspace image to share provider
   */
  private async uploadWorkspaceImage(absolutePath: string, relativePath: string): Promise<string> {
    if (!this.appConfig.share?.provider) {
      throw new Error('Share provider not configured');
    }

    const fileName = path.basename(relativePath);
    const fileContent = fs.readFileSync(absolutePath);

    // Create form data for image upload
    const formData = new FormData();
    const file = new File([fileContent], fileName, {
      type: this.getImageMimeType(absolutePath),
    });

    formData.append('file', file);
    formData.append('type', 'image');
    formData.append('originalPath', relativePath);

    try {
      // FIXME: Support storage.provider
      const storageProvider = this.appConfig.share.provider.replace('/share', '/storage');

      const response = await fetch(storageProvider, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const responseData = await response.json();

      if (responseData) {
        if (responseData.cdnUrl) {
          return ensureHttps(responseData.cdnUrl);
        }

        if (responseData.url) {
          return ensureHttps(responseData.url);
        }
      }

      throw new Error('Invalid response from storage provider for image upload');
    } catch (error) {
      console.error(\`Failed to upload workspace image \${relativePath}:\`, error);
      throw error;
    }
  }

  /**
   * Get MIME type for image file
   */
  private getImageMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: Record<string, string> = {
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.svg': 'image/svg+xml',
    };

    return mimeTypes[ext] || 'application/octet-stream';
  }

  /**
   * Generate shareable HTML content
   */

  private generateShareHtml(
    events: AgentEventStream.Event[],
    metadata: SessionMetadata,
    versionInfo?: AgentServerVersionInfo,
  ): string {
    if (isAgentWebUIImplementationType(this.appConfig.webui!, 'static')) {
      if (!this.appConfig.webui?.staticPath) {
        throw new Error('Cannot found static path.');
      }

      return ShareUtils.generateShareHtml(
        events,
        metadata,
        this.appConfig.webui.staticPath,
        versionInfo,
      );
    }

    // TODO: implement remote web ui
    throw new Error(\`Unsupported web ui type: \${this.appConfig.webui!.type}\`);
  }

  /**
   * Upload share HTML to provider
   */
  private async uploadShareHtml(
    html: string,
    sessionId: string,
    metadata: SessionMetadata,
    agent?: IAgent,
  ): Promise<string> {
    if (!this.appConfig.share?.provider) {
      throw new Error('Share provider not configured');
    }

    // Generate normalized slug if agent is available
    let normalizedSlug = '';
    let originalQuery = '';

    if (this.storageProvider && agent) {
      try {
        const events = await this.storageProvider.getSessionEvents(sessionId);
        const firstUserMessage = events.find((e) => e.type === 'user_message');

        if (firstUserMessage && firstUserMessage.content) {
          originalQuery =
            typeof firstUserMessage.content === 'string'
              ? firstUserMessage.content
              : firstUserMessage.content.find((c) => c.type === 'text')?.text || '';

          if (originalQuery) {
            const slugGenerator = new SlugGenerator(agent);
            normalizedSlug = await slugGenerator.generateSlug(originalQuery);

            // Additional safety check to ensure slug is URL-safe
            normalizedSlug = normalizedSlug.replace(/[^\\x00-\\x7F]+/g, '').replace(/[^\\w-]/g, '');
          }
        }
      } catch (error) {
        console.warn('Failed to extract query for normalized slug:', error);
      }
    }

    if (normalizedSlug) {
      // Generate 6-digit hash from sessionId to avoid conflicts
      const sessionHash = await this.generateSessionHash(sessionId);
      normalizedSlug = \`\${normalizedSlug}-\${sessionHash}\`;
    } else {
      // fallback to sessionId
      normalizedSlug = sessionId;
    }

    return ShareUtils.uploadShareHtml(html, sessionId, this.appConfig.share?.provider as string, {
      metadata,
      slug: normalizedSlug,
      query: originalQuery,
    });
  }

  /**
   * Generate 6-digit hash from sessionId (Cloudflare Worker compatible)
   */
  private async generateSessionHash(sessionId: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(sessionId);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('')
      .slice(0, 6);
  }

  /**
   * Get share configuration
   */
  getShareConfig(): {
    hasShareProvider: boolean;
    shareProvider: string | null;
  } {
    return {
      hasShareProvider: !!this.appConfig.share?.provider,
      shareProvider: this.appConfig.share?.provider || null,
    };
  }
}

--- End of src/services/ShareService.ts ---
=== End of Directory: src/services ===

=== Directory: src/storage ===

--- File: src/storage/DatabaseStorageProvider.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream, AgentStorageImplementation } from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

/**
 * Abstract database storage provider
 * Base class for implementing database-specific storage providers
 * Extend this class to implement storage with MongoDB, PostgreSQL, etc.
 */
export abstract class DatabaseStorageProvider implements StorageProvider {
  protected config: AgentStorageImplementation;

  constructor(config: AgentStorageImplementation) {
    this.config = config;
  }

  abstract initialize(): Promise<void>;
  abstract createSession(metadata: SessionMetadata): Promise<SessionMetadata>;
  abstract updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata>;
  abstract getSessionMetadata(sessionId: string): Promise<SessionMetadata | null>;
  abstract getAllSessions(): Promise<SessionMetadata[]>;
  abstract deleteSession(sessionId: string): Promise<boolean>;
  abstract saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void>;
  abstract getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]>;
  abstract close(): Promise<void>;
}

--- End of src/storage/DatabaseStorageProvider.ts ---

--- File: src/storage/FileStorageProvider.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import path from 'path';
import fs from 'fs';
import { Low } from 'lowdb';
import { JSONFile } from 'lowdb/node';
import {
  AgentEventStream,
  FileAgentStorageImplementation,
  getGlobalStorageDirectory,
  TARKO_CONSTANTS,
} from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

/**
 * Data structure for lowdb
 */
interface DbSchema {
  sessions: Record<string, SessionMetadata>;
  events: Record<string, AgentEventStream.Event[]>;
}

/**
 * File-based storage provider using lowdb
 * Stores data in a JSON file for persistence
 * Suitable for local development and small-scale deployments
 */
export class FileStorageProvider implements StorageProvider {
  private db: Low<DbSchema>;
  private initialized = false;
  public readonly dbPath: string;

  constructor(config: FileAgentStorageImplementation) {
    // Default to the user's home directory
    const baseDir = getGlobalStorageDirectory(config.baseDir);
    const fileName = config.fileName ?? TARKO_CONSTANTS.SESSION_DATA_JSON_NAME;

    // Create the directory if it doesn't exist
    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true });
    }

    this.dbPath = path.join(baseDir, fileName);
    const adapter = new JSONFile<DbSchema>(this.dbPath);
    this.db = new Low<DbSchema>(adapter, { sessions: {}, events: {} });
  }

  async initialize(): Promise<void> {
    if (!this.initialized) {
      try {
        await this.db.read();
        // Initialize if file was empty or new
        this.db.data = this.db.data || { sessions: {}, events: {} };
        this.initialized = true;
      } catch (error) {
        // If file doesn't exist or is invalid JSON, create a new one
        this.db.data = { sessions: {}, events: {} };
        await this.db.write();
        this.initialized = true;
      }
    }
  }

  async createSession(metadata: SessionMetadata): Promise<SessionMetadata> {
    await this.ensureInitialized();

    const sessionData = {
      ...metadata,
      createdAt: metadata.createdAt || Date.now(),
      updatedAt: metadata.updatedAt || Date.now(),
    };

    this.db.data.sessions[metadata.id] = sessionData;
    this.db.data.events[metadata.id] = [];

    await this.db.write();
    return sessionData;
  }

  async updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata> {
    await this.ensureInitialized();

    const session = this.db.data.sessions[sessionId];
    if (!session) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const updatedSession = {
      ...session,
      ...metadata,
      updatedAt: Date.now(),
    };

    this.db.data.sessions[sessionId] = updatedSession;
    await this.db.write();

    return updatedSession;
  }

  async getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
    await this.ensureInitialized();
    return this.db.data.sessions[sessionId] || null;
  }

  async getAllSessions(): Promise<SessionMetadata[]> {
    await this.ensureInitialized();
    return Object.values(this.db.data.sessions);
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    await this.ensureInitialized();

    if (!this.db.data.sessions[sessionId]) {
      return false;
    }

    delete this.db.data.sessions[sessionId];
    delete this.db.data.events[sessionId];

    await this.db.write();
    return true;
  }

  async saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void> {
    await this.ensureInitialized();

    if (!this.db.data.sessions[sessionId]) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    if (!this.db.data.events[sessionId]) {
      this.db.data.events[sessionId] = [];
    }

    this.db.data.events[sessionId].push(event);

    // Update session timestamp
    this.db.data.sessions[sessionId].updatedAt = Date.now();

    await this.db.write();
  }

  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {
    await this.ensureInitialized();

    if (!this.db.data.sessions[sessionId]) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    return this.db.data.events[sessionId] || [];
  }

  async close(): Promise<void> {
    // Make sure any pending writes are flushed
    if (this.initialized) {
      await this.db.write();
    }
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }
}

--- End of src/storage/FileStorageProvider.ts ---

--- File: src/storage/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { StorageProvider } from './types';
import { MemoryStorageProvider } from './MemoryStorageProvider';
import { FileStorageProvider } from './FileStorageProvider';
import { SQLiteStorageProvider } from './SQLiteStorageProvider';
import { AgentStorageImplementation, TARKO_CONSTANTS } from '@tarko/interface';

export * from './types';

/**
 * Creates and returns a storage provider based on the options
 * @param options Storage configuration options
 */
export function createStorageProvider(options?: AgentStorageImplementation): StorageProvider {
  if (!options || options.type === 'memory') {
    return new MemoryStorageProvider();
  }

  if (options.type === 'file') {
    return new FileStorageProvider(options);
  }

  if (options.type === 'sqlite') {
    return new SQLiteStorageProvider(options);
  }

  if (options.type === 'database') {
    throw new Error('Database storage not implemented');
  }

  // @ts-expect-error intercept unexpected storage type
  throw new Error(\`Unknown storage type: \${options.type}\`);
}

--- End of src/storage/index.ts ---

--- File: src/storage/MemoryStorageProvider.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream } from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

/**
 * In-memory storage provider
 * Simple implementation that stores data in memory
 * Useful for testing and development
 * Note: Data will be lost when the server restarts
 */
export class MemoryStorageProvider implements StorageProvider {
  private sessions: Map<string, SessionMetadata> = new Map();
  private events: Map<string, AgentEventStream.Event[]> = new Map();

  async initialize(): Promise<void> {
    // No initialization needed for memory storage
  }

  async createSession(metadata: SessionMetadata): Promise<SessionMetadata> {
    this.sessions.set(metadata.id, {
      ...metadata,
      createdAt: metadata.createdAt || Date.now(),
      updatedAt: metadata.updatedAt || Date.now(),
    });
    this.events.set(metadata.id, []);
    return this.sessions.get(metadata.id)!;
  }

  async updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const updatedSession = {
      ...session,
      ...metadata,
      updatedAt: Date.now(),
    };

    this.sessions.set(sessionId, updatedSession);
    return updatedSession;
  }

  async getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
    return this.sessions.get(sessionId) || null;
  }

  async getAllSessions(): Promise<SessionMetadata[]> {
    return Array.from(this.sessions.values());
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    const deleted = this.sessions.delete(sessionId);
    this.events.delete(sessionId);
    return deleted;
  }

  async saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void> {
    if (!this.sessions.has(sessionId)) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const sessionEvents = this.events.get(sessionId) || [];
    sessionEvents.push(event);
    this.events.set(sessionId, sessionEvents);

    // Update the session's updatedAt timestamp
    await this.updateSessionMetadata(sessionId, { updatedAt: Date.now() });
  }

  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {
    if (!this.sessions.has(sessionId)) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }
    return this.events.get(sessionId) || [];
  }

  async close(): Promise<void> {
    // No cleanup needed for memory storage
  }
}

--- End of src/storage/MemoryStorageProvider.ts ---

--- File: src/storage/SQLiteStorageProvider.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import path from 'path';
import fs from 'fs';
import { DatabaseSync } from 'node:sqlite';
import {
  AgentEventStream,
  getGlobalStorageDirectory,
  SqliteAgentStorageImplementation,
  TARKO_CONSTANTS,
} from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

// Define row types for better type safety
interface SessionRow {
  id: string;
  createdAt: number;
  updatedAt: number;
  name: string | null;
  workspace: string;
  tags: string | null;
}

interface EventRow {
  id: number;
  sessionId: string;
  timestamp: number;
  eventData: string;
}

interface ExistsResult {
  existsFlag: number;
}

/**
 * SQLite-based storage provider using Node.js native SQLite
 * Provides high-performance, file-based storage using the built-in SQLite module
 * Optimized for handling large amounts of event data
 */
export class SQLiteStorageProvider implements StorageProvider {
  private db: DatabaseSync;
  private initialized = false;
  public readonly dbPath: string;

  constructor(config: SqliteAgentStorageImplementation) {
    // Default to the user's home directory
    const baseDir = getGlobalStorageDirectory(config.baseDir);
    const dbName = config.dbName ?? TARKO_CONSTANTS.SESSION_DATA_DB_NAME;

    // Create the directory if it doesn't exist
    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true });
    }

    this.dbPath = path.join(baseDir, dbName);
    this.db = new DatabaseSync(this.dbPath, { open: false });
  }

  async initialize(): Promise<void> {
    if (!this.initialized) {
      try {
        // Open the database
        this.db.open();

        // Enable WAL mode for better concurrent performance
        this.db.exec('PRAGMA journal_mode = WAL');

        // Check if we need to migrate from old schema
        await this.migrateIfNeeded();

        // Create sessions table with current schema
        this.db.exec(\`
          CREATE TABLE IF NOT EXISTS sessions (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workspace TEXT NOT NULL,
            tags TEXT
          )
        \`);

        // Create events table with foreign key to sessions
        this.db.exec(\`
          CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sessionId TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            eventData TEXT NOT NULL,
            FOREIGN KEY (sessionId) REFERENCES sessions (id) ON DELETE CASCADE
          )
        \`);

        // Create index on sessionId for faster queries
        this.db.exec(\`
          CREATE INDEX IF NOT EXISTS idx_events_sessionId ON events (sessionId)
        \`);

        // Enable foreign keys
        this.db.exec('PRAGMA foreign_keys = ON');

        this.initialized = true;
      } catch (error) {
        console.error('Failed to initialize SQLite database:', error);
        throw error;
      }
    }
  }

  /**
   * Check and migrate from old database schema if needed
   */
  private async migrateIfNeeded(): Promise<void> {
    try {
      // Check if sessions table exists and get its schema
      const tableInfoStmt = this.db.prepare(\`
        PRAGMA table_info(sessions)
      \`);

      const columns = tableInfoStmt.all() as Array<{
        cid: number;
        name: string;
        type: string;
        notnull: number;
        dflt_value: any;
        pk: number;
      }>;

      if (columns.length === 0) {
        // Table doesn't exist yet, no migration needed
        return;
      }

      // Check if we have the old 'workingDirectory' column instead of 'workspace'
      const hasWorkingDirectory = columns.some((col) => col.name === 'workingDirectory');
      const hasWorkspace = columns.some((col) => col.name === 'workspace');

      if (hasWorkingDirectory && !hasWorkspace) {
        console.log('Migrating database schema: renaming workingDirectory to workspace');

        // SQLite doesn't support column renaming directly in older versions
        // We need to create a new table and copy data
        this.db.exec(\`
          CREATE TABLE sessions_new (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workspace TEXT NOT NULL,
            tags TEXT
          )
        \`);

        // Copy data from old table to new table
        this.db.exec(\`
          INSERT INTO sessions_new (id, createdAt, updatedAt, name, workspace, tags)
          SELECT id, createdAt, updatedAt, name, workingDirectory, tags
          FROM sessions
        \`);

        // Drop old table and rename new table
        this.db.exec('DROP TABLE sessions');
        this.db.exec('ALTER TABLE sessions_new RENAME TO sessions');

        console.log('Database schema migration completed successfully');
      }
    } catch (error) {
      console.error('Failed to migrate database schema:', error);
      throw new Error(
        \`Database migration failed: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async createSession(metadata: SessionMetadata): Promise<SessionMetadata> {
    await this.ensureInitialized();

    const sessionData = {
      ...metadata,
      createdAt: metadata.createdAt || Date.now(),
      updatedAt: metadata.updatedAt || Date.now(),
    };

    const tagsJson = sessionData.tags ? JSON.stringify(sessionData.tags) : null;

    try {
      const stmt = this.db.prepare(\`
        INSERT INTO sessions (id, createdAt, updatedAt, name, workspace, tags)
        VALUES (?, ?, ?, ?, ?, ?)
      \`);

      stmt.run(
        sessionData.id,
        sessionData.createdAt,
        sessionData.updatedAt,
        sessionData.name || null,
        sessionData.workspace,
        tagsJson,
      );
      return sessionData;
    } catch (error) {
      console.error(\`Failed to create session \${sessionData.id}:\`, error);
      throw new Error(
        \`Failed to create session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata> {
    await this.ensureInitialized();

    // First, get the current session data
    const session = await this.getSessionMetadata(sessionId);
    if (!session) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const updatedSession = {
      ...session,
      ...metadata,
      updatedAt: Date.now(),
    };

    try {
      const params: Array<string | number | null> = [];
      const setClauses: string[] = [];

      if (metadata.name !== undefined) {
        setClauses.push('name = ?');
        params.push(metadata.name || null);
      }

      if (metadata.workspace !== undefined) {
        setClauses.push('workspace = ?');
        params.push(metadata.workspace);
      }

      if (metadata.tags !== undefined) {
        setClauses.push('tags = ?');
        params.push(metadata.tags ? JSON.stringify(metadata.tags) : null);
      }

      // Always update the timestamp
      setClauses.push('updatedAt = ?');
      params.push(updatedSession.updatedAt);

      // Add the session ID for the WHERE clause
      params.push(sessionId);

      if (setClauses.length === 0) {
        return updatedSession; // Nothing to update
      }

      const updateQuery = \`
        UPDATE sessions
        SET \${setClauses.join(', ')}
        WHERE id = ?
      \`;

      const updateStmt = this.db.prepare(updateQuery);
      updateStmt.run(...params);

      return updatedSession;
    } catch (error) {
      console.error(\`Failed to update session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to update session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
    await this.ensureInitialized();

    try {
      const stmt = this.db.prepare(\`
        SELECT id, createdAt, updatedAt, name, workspace, tags
        FROM sessions
        WHERE id = ?
      \`);

      const row = stmt.get(sessionId) as SessionRow | undefined;

      if (!row) {
        return null;
      }

      return {
        id: row.id,
        createdAt: row.createdAt,
        updatedAt: row.updatedAt,
        name: row.name || undefined,
        workspace: row.workspace,
        tags: row.tags ? JSON.parse(row.tags) : undefined,
      };
    } catch (error) {
      console.error(\`Failed to get session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to get session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async getAllSessions(): Promise<SessionMetadata[]> {
    await this.ensureInitialized();

    try {
      const stmt = this.db.prepare(\`
        SELECT id, createdAt, updatedAt, name, workspace, tags
        FROM sessions
        ORDER BY updatedAt DESC
      \`);

      const rows = stmt.all() as unknown as SessionRow[];

      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt,
        updatedAt: row.updatedAt,
        name: row.name || undefined,
        workspace: row.workspace,
        tags: row.tags ? JSON.parse(row.tags) : undefined,
      }));
    } catch (error) {
      console.error('Failed to get all sessions:', error);
      throw new Error(
        \`Failed to get all sessions: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    await this.ensureInitialized();

    try {
      // Delete events first (though the foreign key would handle this)
      const deleteEventsStmt = this.db.prepare('DELETE FROM events WHERE sessionId = ?');
      deleteEventsStmt.run(sessionId);

      // Delete the session
      const deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE id = ?');
      const result = deleteSessionStmt.run(sessionId);

      return result.changes > 0;
    } catch (error) {
      console.error(\`Failed to delete session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to delete session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void> {
    await this.ensureInitialized();

    try {
      // Check if session exists
      const sessionExistsStmt = this.db.prepare(\`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      \`);

      const sessionExists = sessionExistsStmt.get(sessionId) as ExistsResult | undefined;
      if (!sessionExists || !sessionExists.existsFlag) {
        throw new Error(\`Session not found: \${sessionId}\`);
      }

      const timestamp = Date.now();
      const eventData = JSON.stringify(event);

      // Insert the event
      const insertEventStmt = this.db.prepare(\`
        INSERT INTO events (sessionId, timestamp, eventData)
        VALUES (?, ?, ?)
      \`);

      insertEventStmt.run(sessionId, timestamp, eventData);

      // Update session's updatedAt timestamp
      const updateSessionStmt = this.db.prepare(\`
        UPDATE sessions SET updatedAt = ? WHERE id = ?
      \`);

      updateSessionStmt.run(timestamp, sessionId);
    } catch (error) {
      console.error(\`Failed to save event for session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to save event: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {
    await this.ensureInitialized();

    try {
      const sessionExistsStmt = this.db.prepare(\`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      \`);

      const sessionExists = sessionExistsStmt.get(sessionId) as ExistsResult | undefined;
      if (!sessionExists || !sessionExists.existsFlag) {
        throw new Error(\`Session not found: \${sessionId}\`);
      }

      const stmt = this.db.prepare(\`
        SELECT eventData
        FROM events
        WHERE sessionId = ?
        ORDER BY timestamp ASC, id ASC
      \`);

      const rows = stmt.all(sessionId) as unknown as { eventData: string }[];

      return rows.map((row) => {
        try {
          return JSON.parse(row.eventData) as AgentEventStream.Event;
        } catch (error) {
          console.error(\`Failed to parse event data: \${row.eventData}\`);
          return {
            type: 'system',
            message: 'Failed to parse event data',
            timestamp: Date.now(),
          } as AgentEventStream.Event;
        }
      });
    } catch (error) {
      console.error(\`Failed to get events for session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to get session events: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async close(): Promise<void> {
    if (this.db && this.db.isOpen) {
      this.db.close();
    }
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }
}

--- End of src/storage/SQLiteStorageProvider.ts ---

--- File: src/storage/types.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream } from '@tarko/interface';

/**
 * Session metadata interface
 */
export interface SessionMetadata {
  id: string;
  createdAt: number;
  updatedAt: number;
  name?: string;
  workspace: string;
  tags?: string[];
}

/**
 * Abstract storage provider interface
 * Provides methods for storing and retrieving session data
 */
export interface StorageProvider {
  /**
   * DB path.
   */
  dbPath?: string;

  /**
   * Initialize the storage provider
   */
  initialize(): Promise<void>;

  /**
   * Create a new session with metadata
   * @param metadata Session metadata
   */
  createSession(metadata: SessionMetadata): Promise<SessionMetadata>;

  /**
   * Update session metadata
   * @param sessionId Session ID
   * @param metadata Partial metadata to update
   */
  updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata>;

  /**
   * Get session metadata
   * @param sessionId Session ID
   */
  getSessionMetadata(sessionId: string): Promise<SessionMetadata | null>;

  /**
   * Get all sessions metadata
   */
  getAllSessions(): Promise<SessionMetadata[]>;

  /**
   * Delete a session and all its events
   * @param sessionId Session ID
   */
  deleteSession(sessionId: string): Promise<boolean>;

  /**
   * Save an event to a session
   * @param sessionId Session ID
   * @param event Event to save
   */
  saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void>;

  /**
   * Get all events for a session
   * @param sessionId Session ID
   */
  getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]>;

  /**
   * Close the storage provider
   */
  close(): Promise<void>;
}

--- End of src/storage/types.ts ---
=== End of Directory: src/storage ===

=== Directory: src/utils ===

--- File: src/utils/agent-resolver.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  AgentImplementation,
  isAgentImplementationType,
  AgentResolutionResult,
  AgentConstructor,
} from '@tarko/interface';

/**
 * Options for agent implementation resolution
 */
interface AgentResolutionOptions {
  /**
   * Workspace directory path for resolving relative module paths
   */
  workspace?: string;
}

export async function resolveAgentImplementation(
  implementaion?: AgentImplementation,
  options?: AgentResolutionOptions,
): Promise<AgentResolutionResult> {
  if (!implementaion) {
    throw new Error(\`Missing agent implmentation\`);
  }

  if (isAgentImplementationType(implementaion, 'module')) {
    return {
      agentName: implementaion.label ?? implementaion.constructor.label ?? 'Anonymous',
      agentConstructor: implementaion.constructor,
      agioProviderConstructor: implementaion.agio,
    };
  }

  if (isAgentImplementationType(implementaion, 'modulePath')) {
    const agentModulePathIdentifier = implementaion.value;

    try {
      // Build resolve options with workspace path if provided
      const resolveOptions: { paths?: string[] } = {};
      if (options?.workspace) {
        resolveOptions.paths = [options.workspace];
      }

      // First, use require.resolve to validate module existence and get absolute path
      // This handles npm packages, relative paths, and directories more robustly
      // When workspace is provided, it will be used as the base path for relative imports
      const resolvedPath = require.resolve(agentModulePathIdentifier, resolveOptions);

      // Use the resolved absolute path for import to ensure consistency
      const agentModule = await import(resolvedPath);

      // Handle nested default exports (common in transpiled modules)
      let agentConstructor = agentModule.default as AgentConstructor;

      // Check for double default nesting (e.g., agentModule.default.default)
      if (
        agentConstructor &&
        typeof agentConstructor === 'object' &&
        'default' in agentConstructor
      ) {
        // @ts-expect-error
        agentConstructor = agentConstructor.default as AgentConstructor;
      }

      if (!agentConstructor || typeof agentConstructor !== 'function') {
        throw new Error(
          \`Invalid agent module at '\${agentModulePathIdentifier}': Must export an Agent constructor as default export.\`,
        );
      }

      return {
        agentName: implementaion.label ?? agentConstructor.label ?? 'Anonymous',
        agentConstructor,
        agioProviderConstructor: implementaion.agio,
      };
    } catch (error) {
      throw new Error(
        \`Failed to resolve agent module '\${agentModulePathIdentifier}': \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  throw new Error(\`Non-supported agent type: \${implementaion.type}\`);
}

--- End of src/utils/agent-resolver.ts ---

--- File: src/utils/error-handler.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * ErrorWithCode - Extended Error class with error code
 * Provides structured error information for better handling
 */
export class ErrorWithCode extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: Record<string, any>,
  ) {
    super(message);
    this.name = 'AgentError';
  }
}

/**
 * Safely handles agent errors to prevent process crashes
 * @param error The error to handle
 * @param context Additional context for logging
 * @returns Normalized error object
 */
export function handleAgentError(error: unknown, context?: string): ErrorWithCode {
  // Log the error with context
  console.error(\`Agent error\${context ? \` [\${context}]\` : ''}:\`, error);

  // Normalize to ErrorWithCode
  if (error instanceof ErrorWithCode) {
    return error;
  }

  // Create structured error from generic error
  if (error instanceof Error) {
    return new ErrorWithCode(error.message, 'AGENT_EXECUTION_ERROR', { stack: error.stack });
  }

  // Handle non-Error objects
  return new ErrorWithCode(
    typeof error === 'string' ? error : 'Unknown agent execution error',
    'UNKNOWN_ERROR',
    { originalError: error },
  );
}

/**
 * Error response structure for agent errors
 */
export interface AgentErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
}

/**
 * Creates a standardized error response
 */
export function createErrorResponse(error: unknown): AgentErrorResponse {
  const normalizedError = handleAgentError(error);

  return {
    success: false,
    error: {
      code: normalizedError.code,
      message: normalizedError.message,
      details: normalizedError.details,
    },
  };
}

--- End of src/utils/error-handler.ts ---

--- File: src/utils/event-stream.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream } from '@tarko/interface';

/**
 * Implement event stream bridging to forward Agent's native events to the client
 */
export class EventStreamBridge {
  private subscribers: Set<(type: string, data: any) => void> = new Set();

  /**
   * Subscribe to events
   * @param handler event processing function
   */
  subscribe(handler: (type: string, data: any) => void): void {
    this.subscribers.add(handler);
  }

  /**
   * Unsubscribe event
   * @param handler event processing function
   */
  unsubscribe(handler: (type: string, data: any) => void): void {
    this.subscribers.delete(handler);
  }

  /**
   * Publish event
   * @param type event type
   * @param data event data
   */
  emit(type: string, data: any): void {
    for (const handler of this.subscribers) {
      handler(type, data);
    }
  }

  /**
   * Event stream manager connected to Agent
   * @param agentEventStream Agent's event stream manager
   * @returns Unsubscribe function
   */
  connectToAgentEventStream(agentEventStream: AgentEventStream.Processor): () => void {
    const handleEvent = (event: AgentEventStream.Event) => {
      // Mapping event types to socket.io-friendly events
      switch (event.type) {
        case 'agent_run_start':
          // processing
          this.emit('agent-status', { isProcessing: true, state: 'executing' });
          break;

        case 'agent_run_end':
          // 
          this.emit('agent-status', { isProcessing: false, state: event.status || 'idle' });
          break;

        case 'user_message':
          // 
          this.emit('agent-status', { isProcessing: true, state: 'processing' });
          this.emit('query', { text: event.content });
          break;
        case 'assistant_message':
          this.emit('answer', { text: event.content });
          break;
        case 'tool_call':
          this.emit('event', {
            type: 'tool_call',
            name: event.name,
            toolCallId: event.toolCallId,
            arguments: event.arguments,
          });
          break;
        case 'tool_result':
          this.emit('event', {
            type: 'tool_result',
            name: event.name,
            toolCallId: event.toolCallId,
            content: event.content,
            error: event.error,
          });
          break;
        case 'system':
          this.emit(event.level, { message: event.message });
          break;
        default:
          this.emit('event', event);
      }

      // 
      if (event.type === 'system' && event.message?.includes('aborted')) {
        this.emit('aborted', { message: event.message });
        // 
        this.emit('agent-status', { isProcessing: false, state: 'idle' });
      }

      // Add handling for status events
      if (event.type === 'system' && event.message?.includes('status')) {
        this.emit('status', { message: event.message });
      }
    };

    // Subscribe to the Agent's event stream
    return agentEventStream.subscribe(handleEvent);
  }
}

--- End of src/utils/event-stream.ts ---

--- File: src/utils/index.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './error-handler';
export * from './workspace-static-server';
export * from './url';
export * from './agent-resolver';

--- End of src/utils/index.ts ---

--- File: src/utils/share.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'fs';
import path from 'path';
import os from 'os';
import { AgentEventStream, AgentServerVersionInfo } from '@tarko/interface';
import { SessionMetadata } from '../storage';

/**
 * ShareUtils - Utility functions for sharing session data
 *
 * Provides methods for:
 * - Generating HTML for sharing
 * - Uploading share HTML to providers
 * - Uploading individual files to share providers
 */
export class ShareUtils {
  /**
   * Generate shareable HTML content for a session
   * @param events Session events to include
   * @param metadata Session metadata
   * @param staticPath Path to static web UI files
   * @param serverInfo Optional server version info
   * @returns Generated HTML content
   */
  static generateShareHtml(
    events: AgentEventStream.Event[],
    metadata: SessionMetadata,
    staticPath: string,
    serverInfo?: AgentServerVersionInfo,
  ): string {
    if (!staticPath) {
      throw new Error('Cannot found static path.');
    }

    const indexPath = path.join(staticPath, 'index.html');
    if (!fs.existsSync(indexPath)) {
      throw new Error('Static web ui not found.');
    }

    try {
      let htmlContent = fs.readFileSync(indexPath, 'utf8');

      const safeEventJson = this.safeJsonStringify(events);
      const safeMetadataJson = this.safeJsonStringify(metadata);
      const safeVersionJson = serverInfo ? this.safeJsonStringify(serverInfo) : null;

      // Inject session data, event stream, and version info
      const scriptTag = \`<script>
        window.AGENT_REPLAY_MODE = true;
        window.AGENT_SESSION_DATA = \${safeMetadataJson};
        window.AGENT_EVENT_STREAM = \${safeEventJson};\${
          safeVersionJson
            ? \`
        window.AGENT_VERSION_INFO = \${safeVersionJson};\`
            : ''
        }
      </script>
      <script>
        // Add a fallback mechanism for when routes don't match in shared HTML files
        window.addEventListener('DOMContentLoaded', function() {
          // Give React time to attempt normal routing
          setTimeout(function() {
            const root = document.getElementById('root');
            if (root && (!root.children || root.children.length === 0)) {
              console.log('[ReplayMode] No content rendered, applying fallback');
              // Try to force the app to re-render if no content is displayed
              window.dispatchEvent(new Event('resize'));
            }
          }, 1000);
        });
      </script>\`;

      // Insert script before the head end tag
      htmlContent = htmlContent.replace('</head>', \`\${scriptTag}\\n</head>\`);

      return htmlContent;
    } catch (error) {
      console.error('Failed to generate share HTML:', error);
      throw new Error(
        \`Failed to generate share HTML: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  /**
   * Safely stringify JSON data containing HTML content
   * This ensures HTML in the data won't break the embedding script
   * @param data The data to stringify
   * @returns Safe JSON string
   */
  private static safeJsonStringify(data: object): string {
    let jsonString = JSON.stringify(data);

    // Escape all characters that may destroy the HTML structure
    // 1. Escape all angle brackets to prevent any HTML tags from being parsed by the browser
    jsonString = jsonString.replace(/</g, '\\\\u003C');
    jsonString = jsonString.replace(/>/g, '\\\\u003E');

    // 2. Escape other potentially dangerous characters
    jsonString = jsonString.replace(/\\//g, '\\\\/'); // Escape slashes to prevent closing tags such as </script>

    return jsonString;
  }

  /**
   * Upload HTML to a share provider
   * @param html HTML content to upload
   * @param sessionId Session ID
   * @param shareProviderUrl URL of the share provider
   * @param options Additional share metadata options
   * @returns URL of the shared content
   */
  static async uploadShareHtml(
    html: string,
    sessionId: string,
    shareProviderUrl: string,
    options?: {
      /**
       * Session metadata containing additional session information
       */
      metadata?: SessionMetadata;

      /**
       * Normalized slug for semantic URLs, derived from user query
       */
      slug?: string;

      /**
       * Original query that initiated the conversation
       */
      query?: string;
    },
  ): Promise<string> {
    if (!shareProviderUrl) {
      throw new Error('Share provider not configured');
    }

    try {
      // Create temporary directory
      const tempDir = path.join(os.tmpdir(), 'agent-tars-share');
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      const fileName = \`agent-tars-\${sessionId}-\${Date.now()}.html\`;
      const filePath = path.join(tempDir, fileName);

      // Write HTML content to temporary file
      fs.writeFileSync(filePath, html);

      // Create form data using native FormData
      const formData = new FormData();

      // Create a File object from the HTML content
      const file = new File([html], fileName, { type: 'text/html' });
      formData.append('file', file);
      formData.append('sessionId', sessionId);
      formData.append('type', 'html'); // Specify this is HTML content

      // Add additional metadata fields if provided
      if (options) {
        // Add normalized slug for semantic URLs
        if (options.slug) {
          formData.append('slug', options.slug);
        }

        // Add original query
        if (options.query) {
          formData.append('query', options.query);
        }

        // Add session metadata fields
        if (options.metadata) {
          formData.append('name', options.metadata.name || '');
          // Add tags if available
          if (options.metadata.tags && options.metadata.tags.length > 0) {
            formData.append('tags', JSON.stringify(options.metadata.tags));
          }
        }
      }

      // Send request to share provider using fetch
      const response = await fetch(shareProviderUrl, {
        method: 'POST',
        body: formData,
      });

      // Clean up temporary file
      fs.unlinkSync(filePath);

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const responseData = await response.json();

      // Return share URL
      if (responseData && responseData.url) {
        return responseData.url;
      }

      throw new Error('Invalid response from share provider');
    } catch (error) {
      console.error('Failed to upload share HTML:', error);
      throw error;
    }
  }

  /**
   * Upload a file to share provider
   * @param filePath Path to the file to upload
   * @param fileName Name for the uploaded file
   * @param shareProviderUrl URL of the share provider
   * @param options Additional upload options
   * @returns URL of the uploaded file
   */
  static async uploadFile(
    filePath: string,
    fileName: string,
    shareProviderUrl: string,
    options?: {
      /**
       * File type (e.g., 'image', 'document')
       */
      type?: string;
      /**
       * Original relative path of the file
       */
      originalPath?: string;
      /**
       * Additional metadata
       */
      metadata?: Record<string, string>;
    },
  ): Promise<string> {
    if (!shareProviderUrl) {
      throw new Error('Share provider not configured');
    }

    if (!fs.existsSync(filePath)) {
      throw new Error(\`File not found: \${filePath}\`);
    }

    try {
      const fileContent = fs.readFileSync(filePath);

      // Create form data using native FormData
      const formData = new FormData();

      // Create a File object from the file content
      const file = new File([fileContent], fileName, {
        type: this.getMimeType(filePath),
      });

      formData.append('file', file);
      formData.append('type', options?.type || 'file');

      if (options?.originalPath) {
        formData.append('originalPath', options.originalPath);
      }

      // Add additional metadata if provided
      if (options?.metadata) {
        for (const [key, value] of Object.entries(options.metadata)) {
          formData.append(key, value);
        }
      }

      // Send request to share provider using fetch
      const response = await fetch(shareProviderUrl, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const responseData = await response.json();

      // Return file URL
      if (responseData && responseData.url) {
        return responseData.url;
      }

      throw new Error('Invalid response from share provider for file upload');
    } catch (error) {
      console.error(\`Failed to upload file \${filePath}:\`, error);
      throw error;
    }
  }

  /**
   * Get MIME type for a file based on its extension
   */
  private static getMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: Record<string, string> = {
      // Images
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.svg': 'image/svg+xml',
      // Documents
      '.pdf': 'application/pdf',
      '.txt': 'text/plain',
      '.md': 'text/markdown',
      '.html': 'text/html',
      '.css': 'text/css',
      '.js': 'application/javascript',
      '.json': 'application/json',
      // Archives
      '.zip': 'application/zip',
      '.tar': 'application/x-tar',
      '.gz': 'application/gzip',
    };

    return mimeTypes[ext] || 'application/octet-stream';
  }
}

--- End of src/utils/share.ts ---

--- File: src/utils/slug-generator.ts ---
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { IAgent } from '@tarko/interface';

/**
 * Response schema for LLM-generated slug
 */
interface SlugResponse {
  /**
   * Generated slug containing 3-5 words separated by hyphens
   */
  slug: string;
}

/**
 * SlugGenerator - Intelligent slug generation using LLM JSON mode
 *
 * This class provides AI-powered slug generation that can handle multilingual content
 * and produce semantic, URL-friendly slugs. It uses the LLM's JSON mode to ensure
 * structured output and proper formatting.
 *
 * Key features:
 * - Multilingual support (Chinese, English, etc.)
 * - Semantic understanding of content
 * - Consistent 3-5 word length
 * - URL-safe formatting
 * - Internal fallback to manual normalization if LLM fails
 */
export class SlugGenerator {
  constructor(private agent: IAgent) {}

  /**
   * Generate a semantic slug from user message
   * Handles all normalization logic internally, no external fallback needed
   *
   * @param userMessage The original user message to generate slug from
   * @returns Promise resolving to a normalized slug string
   */
  async generateSlug(userMessage: string): Promise<string> {
    if (!userMessage.trim()) {
      return this.getDefaultSlug();
    }

    try {
      // Try LLM-powered generation first
      const llmSlug = await this.generateWithLLM(userMessage);
      if (llmSlug) {
        return llmSlug;
      }
    } catch (error) {
      console.warn('LLM slug generation failed, using manual normalization:', error);
    }

    // Fallback to manual normalization
    return this.manualNormalization(userMessage);
  }

  /**
   * Generate slug using LLM JSON mode
   */
  private async generateWithLLM(userMessage: string): Promise<string | null> {
    const response = await this.agent.callLLM({
      messages: [
        {
          role: 'system',
          content: \`You are a URL slug generator. Generate a semantic, URL-friendly slug from the given text.

Requirements:
- Use 3-5 words separated by hyphens
- Use only lowercase English words
- No special characters except hyphens
- Capture the main topic/intent of the text
- Handle multilingual input (Chinese, English, etc.)
- NEVER include non-ASCII characters like Chinese in the output

Return only a JSON object with a "slug" field.\`,
        },
        {
          role: 'user',
          content: \`Generate a slug for: "\${userMessage}"\`,
        },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.3,
      max_tokens: 100,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      return null;
    }

    try {
      const parsed = JSON.parse(content) as SlugResponse;

      // Apply manual normalization to ensure LLM output is also sanitized
      return this.manualNormalization(parsed.slug);
    } catch (error) {
      console.error('Failed to parse LLM slug response:', error);
      return null;
    }
  }

  /**
   * Manual normalization - the consolidated logic from all places
   */
  private manualNormalization(text: string): string {
    // First, attempt to transliterate non-ASCII characters
    // Then apply standard normalization
    const normalized = text
      .toLowerCase()
      // First, remove all non-ASCII characters completely
      .replace(/[^\\x00-\\x7F]+/g, '-')
      .replace(/[^\\w\\s-]/g, '') // Remove remaining special characters
      .replace(/\\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Remove consecutive hyphens
      .substring(0, 60) // Limit length
      .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens

    if (!normalized || normalized.length === 0) {
      return this.getDefaultSlug();
    }

    // Take first few words if too long
    const words = normalized.split('-').filter((word) => word.length > 0);
    return words.slice(0, 4).join('-') || this.getDefaultSlug();
  }

  /**
   * Get default slug when all else fails
   */
  private getDefaultSlug(): string {
    return 'untitled-session';
  }
}

--- End of src/utils/slug-generator.ts ---

--- File: src/utils/url.ts ---
/**
 * Ensure URL has HTTPS prefix
 */
export function ensureHttps(url: string): string {
  if (!url) return url;

  if (url.startsWith('http://') || url.startsWith('https://')) {
    if (url.startsWith('http://')) {
      return url.replace('http://', 'https://');
    }
    return url;
  }

  if (url.startsWith('//')) {
    return \`https:\${url}\`;
  }

  return \`https://\${url}\`;
}

--- End of src/utils/url.ts ---

--- File: src/utils/workspace-static-server.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import path from 'path';
import fs from 'fs';

/**
 * Extract session ID from referer URL
 * @param referer The referer header value
 * @returns Session ID or null if not found
 */
function extractSessionIdFromReferer(referer: string | undefined): string | undefined {
  if (!referer) {
    return;
  }

  try {
    const url = new URL(referer);
    const pathParts = url.pathname.split('/').filter(Boolean);

    // Assume the last non-empty path segment is the session ID
    // You might want to adjust this logic based on your URL structure
    if (pathParts.length > 0) {
      const potentialSessionId = pathParts[pathParts.length - 1];

      // Basic validation - session ID should be alphanumeric and of reasonable length
      if (/^[a-zA-Z0-9_-]{10,}$/.test(potentialSessionId)) {
        return potentialSessionId;
      }
    }
  } catch (error) {
    // Invalid URL, ignore
  }

  return;
}

/**
 * Workspace file resolver that handles session isolation and absolute paths
 */
export class WorkspaceFileResolver {
  constructor(private baseWorkspacePath: string) {}

  /**
   * Resolve file path considering session isolation and security
   * @param requestPath The requested file path
   * @param sessionId Optional session ID for isolated sessions
   * @returns Resolved file path or null if not found/not allowed
   */
  resolveFilePath(requestPath: string, sessionId?: string): string | null {
    // Security check: prevent path traversal
    const normalizedPath = path.normalize(requestPath);
    if (normalizedPath.includes('..')) {
      return null;
    }

    const pathsToTry: string[] = [];

    pathsToTry.push(normalizedPath);

    // Always try the base workspace path as fallback
    const basePath = path.join(this.baseWorkspacePath, normalizedPath);
    pathsToTry.push(basePath);

    // Find the first existing file
    for (const filePath of pathsToTry) {
      if (this.isPathSafe(filePath) && fs.existsSync(filePath)) {
        return filePath;
      }
    }

    return null;
  }

  /**
   * Security check: ensure the resolved path is within allowed directories
   */
  private isPathSafe(filePath: string): boolean {
    const resolvedPath = path.resolve(filePath);
    const resolvedWorkspace = path.resolve(this.baseWorkspacePath);

    return resolvedPath.startsWith(resolvedWorkspace);
  }

  /**
   * List all accessible directories for a given session
   * @param sessionId Optional session ID
   * @returns Array of accessible directory paths
   */
  getAccessibleDirectories(sessionId?: string): string[] {
    const directories: string[] = [];

    // Add base workspace directory
    if (fs.existsSync(this.baseWorkspacePath)) {
      directories.push(this.baseWorkspacePath);
    }

    return directories;
  }
}

/**
 * Handle directory listing with session-aware navigation
 */
function handleDirectoryListing(
  req: express.Request,
  res: express.Response,
  directoryPath: string,
  fileResolver: WorkspaceFileResolver,
  sessionId: string | undefined,
  baseWorkspacePath: string,
): express.Response {
  try {
    const files = fs.readdirSync(directoryPath).map((file) => {
      const filePath = path.join(directoryPath, file);
      const fileStats = fs.statSync(filePath);
      return {
        name: file,
        isDirectory: fileStats.isDirectory(),
        size: fileStats.size,
        modified: fileStats.mtime,
      };
    });

    const relativePath = path.relative(baseWorkspacePath, directoryPath);
    const breadcrumb = relativePath ? relativePath.split(path.sep) : [];

    // Add session context to the listing
    const sessionContext = sessionId ? \` (Session: \${sessionId})\` : '';
    const html = generateDirectoryListingHTML(
      files,
      req.path,
      breadcrumb,
      sessionContext,
      sessionId,
    );
    return res.send(html);
  } catch (error) {
    return res.status(500).json({ error: 'Failed to read directory' });
  }
}

/**
 * Generate HTML for directory listing with session context
 */
function generateDirectoryListingHTML(
  files: Array<{ name: string; isDirectory: boolean; size: number; modified: Date }>,
  currentPath: string,
  breadcrumb: string[],
  sessionContext = '',
  sessionId?: string,
): string {
  const title = \`Directory: \${currentPath}\${sessionContext}\`;

  const breadcrumbHTML =
    breadcrumb.length > 0
      ? breadcrumb
          .map((part, index) => {
            const href = '/' + breadcrumb.slice(0, index + 1).join('/');
            const sessionParam = sessionId ? \`?sessionId=\${sessionId}\` : '';
            return \`<a href="\${href}\${sessionParam}">\${part}</a>\`;
          })
          .join(' / ')
      : 'workspace';

  const parentLink =
    currentPath !== '/'
      ? \`<tr><td><a href="\${path.dirname(currentPath)}\${sessionId ? \`?sessionId=\${sessionId}\` : ''}"> ..</a></td><td>-</td><td>-</td></tr>\`
      : '';

  const fileRows = files
    .sort((a, b) => {
      // Directories first, then files
      if (a.isDirectory && !b.isDirectory) return -1;
      if (!a.isDirectory && b.isDirectory) return 1;
      return a.name.localeCompare(b.name);
    })
    .map((file) => {
      const icon = file.isDirectory ? '' : '';
      const href = path.join(currentPath, file.name).replace(/\\\\/g, '/');
      const sessionParam = sessionId ? \`?sessionId=\${sessionId}\` : '';
      const size = file.isDirectory ? '-' : formatFileSize(file.size);
      const modified =
        file.modified.toLocaleDateString() + ' ' + file.modified.toLocaleTimeString();

      return \`<tr>
        <td><a href="\${href}\${sessionParam}">\${icon} \${file.name}</a></td>
        <td>\${size}</td>
        <td>\${modified}</td>
      </tr>\`;
    })
    .join('');

  return \`<!DOCTYPE html>
<html>
<head>
    <title>\${title}</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1 { color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        .breadcrumb { margin-bottom: 20px; color: #666; }
        .session-info { margin-bottom: 20px; padding: 10px; background-color: #f0f8ff; border-radius: 5px; color: #0066cc; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #eee; }
        th { background-color: #f5f5f5; font-weight: bold; }
        a { text-decoration: none; color: #0066cc; }
        a:hover { text-decoration: underline; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 12px; }
    </style>
</head>
<body>
    <h1>Agent Workspace\${sessionContext}</h1>
    \${sessionId ? \`<div class="session-info"> Browsing files for session: <strong>\${sessionId}</strong></div>\` : ''}
    <div class="breadcrumb"> \${breadcrumbHTML}</div>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Size</th>
                <th>Modified</th>
            </tr>
        </thead>
        <tbody>
            \${parentLink}
            \${fileRows}
        </tbody>
    </table>
    <div class="footer">
        Agent Workspace Static Server\${sessionContext}
        \${sessionId ? \`<br/>Tip: Remove <code>?sessionId=\${sessionId}</code> from URL to browse base workspace\` : ''}
    </div>
</body>
</html>\`;
}

/**
 * Format file size in human readable format
 */
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

/**
 * Setup workspace static server with session isolation support
 * Serves static files from workspace directories with proper session handling
 * @param app Express application instance
 * @param workspacePath Path to workspace directory
 * @param isDebug Whether to show debug logs
 */
export function setupWorkspaceStaticServer(
  app: express.Application,
  workspacePath: string,
  isDebug = false,
): void {
  if (!workspacePath || !fs.existsSync(workspacePath)) {
    if (isDebug) {
      console.log('Workspace path not found, skipping static server setup');
    }
    return;
  }

  if (isDebug) {
    console.log(\`Setting up workspace static server at: \${workspacePath}\`);
  }

  const fileResolver = new WorkspaceFileResolver(workspacePath);

  // Serve workspace files with lower priority (after web UI)
  // Use a middleware function to handle directory listing and file serving
  app.use('/', (req, res, next) => {
    // Skip if this looks like an API request
    if (req.path.startsWith('/api/')) {
      return next();
    }

    // Skip if this looks like a web UI route (no file extension and not a static asset)
    if (
      !req.path.includes('.') &&
      !req.path.startsWith('/static/') &&
      !req.path.startsWith('/assets/')
    ) {
      return next();
    }

    // Try to extract session ID from query params or headers
    const sessionId =
      (req.query.sessionId as string) ||
      (req.headers['x-session-id'] as string) ||
      extractSessionIdFromReferer(req.headers.referer);

    // Resolve the file path using the file resolver
    const resolvedPath = fileResolver.resolveFilePath(req.path, sessionId);
    if (!resolvedPath) {
      return next();
    }

    try {
      const stats = fs.statSync(resolvedPath);

      if (stats.isFile()) {
        // Serve the file
        return res.sendFile(resolvedPath);
      } else if (stats.isDirectory()) {
        // For directories, try to serve index.html or provide directory listing
        const indexPath = path.join(resolvedPath, 'index.html');
        if (fs.existsSync(indexPath)) {
          return res.sendFile(indexPath);
        } else {
          // Provide directory listing with session context
          return handleDirectoryListing(
            req,
            res,
            resolvedPath,
            fileResolver,
            sessionId,
            workspacePath,
          );
        }
      }
    } catch (error) {
      // File access error, continue to next middleware
      return next();
    }

    // File not found, continue to next middleware
    next();
  });
}

--- End of src/utils/workspace-static-server.ts ---
=== End of Directory: src/utils ===
",
  "files": [
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './sessions';
export * from './queries';
export * from './system';
export * from './share';
export * from './oneshot';
",
      "hasError": false,
      "relativePath": "src/api/controllers/index.ts",
      "size": 238,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { ChatCompletionContentPart } from '@tarko/interface';
import { nanoid } from 'nanoid';
import { SessionMetadata } from '../../storage';
import { AgentSession } from '../../core';
import { createErrorResponse } from '../../utils/error-handler';

/**
 * Interface for one-shot query request body
 */
interface OneshotQueryRequest {
  /**
   * Query content to be processed
   */
  query: string | ChatCompletionContentPart[];

  /**
   * Optional session name to identify the session
   */
  sessionName?: string;

  /**
   * Optional session tags for organization
   */
  sessionTags?: string[];
}

/**
 * Execute a query in a newly created session (non-streaming)
 */
export async function createAndQuery(req: Request, res: Response) {
  try {
    const { query, sessionName, sessionTags } = req.body as OneshotQueryRequest;

    if (!query) {
      return res.status(400).json({ error: 'Query is required' });
    }

    // Create new session
    const server = req.app.locals.server;
    const sessionId = nanoid();

    // Create session with custom AGIO provider if available
    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

    server.sessions[sessionId] = session;

    // Initialize session
    const { storageUnsubscribe } = await session.initialize();

    // Save unsubscribe function for cleanup
    if (storageUnsubscribe) {
      server.storageUnsubscribes[sessionId] = storageUnsubscribe;
    }

    // Store session metadata if storage is available
    if (server.storageProvider) {
      const metadata: SessionMetadata = {
        id: sessionId,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        name: sessionName,
        workspace: server.getCurrentWorkspace(),
        tags: sessionTags,
      };

      await server.storageProvider.createSession(metadata);
    }

    // Execute query on new session
    const response = await session.runQuery(query);

    if (response.success) {
      res.status(200).json({
        sessionId,
        result: response.result,
      });
    } else {
      // Send structured error response with 500 status
      res.status(500).json({
        sessionId,
        ...response,
      });
    }
  } catch (error) {
    console.error(\`Unexpected error in createAndQuery:\`, error);
    res.status(500).json(createErrorResponse(error));
  }
}

/**
 * Execute a streaming query in a newly created session
 */
export async function createAndStreamingQuery(req: Request, res: Response) {
  try {
    const { query, sessionName, sessionTags } = req.body as OneshotQueryRequest;

    if (!query) {
      return res.status(400).json({ error: 'Query is required' });
    }

    // Create new session
    const server = req.app.locals.server;
    const sessionId = nanoid();

    // Create session with custom AGIO provider if available
    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

    server.sessions[sessionId] = session;

    // Initialize session
    const { storageUnsubscribe } = await session.initialize();

    // Save unsubscribe function for cleanup
    if (storageUnsubscribe) {
      server.storageUnsubscribes[sessionId] = storageUnsubscribe;
    }

    // Store session metadata if storage is available
    if (server.storageProvider) {
      const metadata: SessionMetadata = {
        id: sessionId,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        name: sessionName,
        workspace: server.getCurrentWorkspace(),
        tags: sessionTags,
      };

      await server.storageProvider.createSession(metadata);
    }

    // Set response headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // Send session ID as the first event
    res.write(
      \`data: \${JSON.stringify({
        type: 'session_created',
        sessionId,
        timestamp: Date.now(),
      })}\\n\\n\`,
    );

    // Get streaming response
    const eventStream = await session.runQueryStreaming(query);

    // Stream events one by one
    for await (const event of eventStream) {
      const isErrorEvent = event.type === 'system' && event.level === 'error';

      // Only send data when connection is still open
      if (!res.closed) {
        res.write(\`data: \${JSON.stringify(event)}\\n\\n\`);

        // If we encounter an error event, end streaming
        if (isErrorEvent) {
          break;
        }
      } else {
        break;
      }
    }

    // End the stream response
    if (!res.closed) {
      res.end();
    }
  } catch (error) {
    console.error(\`Critical error in streaming query creation:\`, error);

    if (!res.headersSent) {
      res.status(500).json(createErrorResponse(error));
    } else {
      const errorObj = createErrorResponse(error);
      res.write(
        \`data: \${JSON.stringify({
          type: 'system',
          level: 'error',
          message: errorObj.error.message,
          timestamp: Date.now(),
        })}\\n\\n\`,
      );
      res.end();
    }
  }
}
",
      "hasError": false,
      "relativePath": "src/api/controllers/oneshot.ts",
      "size": 5253,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { createErrorResponse } from '../../utils/error-handler';
import { ContextReferenceProcessor, ImageProcessor } from '@tarko/context-engineer/node';

const imageProcessor = new ImageProcessor({
  quality: 5,
  format: 'webp',
});

const contextReferenceProcessor = new ContextReferenceProcessor({
  maxFileSize: 2 * 1024 * 1024, // 2MB limit for LLM context
  ignoreExtensions: [
    '.jpg',
    '.jpeg',
    '.png',
    '.gif',
    '.webp',
    '.svg',
    '.pdf',
    '.zip',
    '.tar',
    '.gz',
    '.exe',
    '.dll',
  ],
  ignoreDirs: ['node_modules', '.git', '.next', 'dist', 'build', 'coverage', '.vscode', '.idea'],
  maxDepth: 8,
});

/**
 * Execute a non-streaming query
 */
export async function executeQuery(req: Request, res: Response) {
  const { sessionId, query } = req.body;

  if (!query) {
    return res.status(400).json({ error: 'Query is required' });
  }

  try {
    // Get server instance to access workspace path
    const server = req.app.locals.server;
    const workspacePath = server.getCurrentWorkspace();

    // Process contextual references first
    const processedQuery = await contextReferenceProcessor.processContextualReferences(
      query,
      workspacePath,
    );

    // Compress images in processed query
    const compressedQuery = await imageProcessor.compressImagesInQuery(processedQuery);

    // Use enhanced error handling in runQuery
    const response = await req.session!.runQuery(compressedQuery);

    if (response.success) {
      res.status(200).json({ result: response.result });
    } else {
      // Send structured error response with 500 status
      res.status(500).json(response);
    }
  } catch (error) {
    // This should never happen with the new error handling, but just in case
    console.error(\`Unexpected error processing query in session \${sessionId}:\`, error);
    res.status(500).json(createErrorResponse(error));
  }
}

/**
 * Execute a streaming query
 */
export async function executeStreamingQuery(req: Request, res: Response) {
  const { sessionId, query } = req.body;

  if (!query) {
    return res.status(400).json({ error: 'Query is required' });
  }

  try {
    // Set response headers for streaming
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    // Get server instance to access workspace path
    const server = req.app.locals.server;
    const workspacePath = server.getCurrentWorkspace();

    // Process contextual references first
    const processedQuery = await contextReferenceProcessor.processContextualReferences(
      query,
      workspacePath,
    );

    // Compress images in processed query
    const compressedQuery = await imageProcessor.compressImagesInQuery(processedQuery);

    // Get streaming response - any errors will be returned as events
    const eventStream = await req.session!.runQueryStreaming(compressedQuery);

    // Stream events one by one
    for await (const event of eventStream) {
      // Check for error events
      const isErrorEvent = event.type === 'system' && event.level === 'error';

      // Only send data when connection is still open
      if (!res.closed) {
        res.write(\`data: \${JSON.stringify(event)}\\n\\n\`);

        // If we encounter an error event, end streaming
        if (isErrorEvent) {
          break;
        }
      } else {
        break;
      }
    }

    // End the stream response
    if (!res.closed) {
      res.end();
    }
  } catch (error) {
    // This should almost never happen with the new error handling
    console.error(\`Critical error in streaming query for session \${sessionId}:\`, error);

    if (!res.headersSent) {
      res.status(500).json(createErrorResponse(error));
    } else {
      const errorObj = createErrorResponse(error);
      res.write(
        \`data: \${JSON.stringify({
          type: 'system',
          level: 'error',
          message: errorObj.error.message,
          timestamp: Date.now(),
        })}\\n\\n\`,
      );
      res.end();
    }
  }
}

/**
 * Abort a running query
 */
export async function abortQuery(req: Request, res: Response) {
  const { sessionId } = req.body;

  try {
    const aborted = req.session!.abortQuery();
    res.status(200).json({ success: aborted });
  } catch (error) {
    console.error(\`Error aborting query in session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to abort query' });
  }
}
",
      "hasError": false,
      "relativePath": "src/api/controllers/queries.ts",
      "size": 4628,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { nanoid } from 'nanoid';
import { SessionMetadata } from '../../storage';
import { AgentSession } from '../../core';
import { ShareService } from '../../services';
import * as path from 'path';
import * as fs from 'fs';

/**
 * Get all sessions
 */
export async function getAllSessions(req: Request, res: Response) {
  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      // If no storage, return only active sessions
      const activeSessions = Object.keys(server.sessions).map((id) => ({
        id,
        createdAt: Date.now(),
        updatedAt: Date.now(),
      }));
      return res.status(200).json({ sessions: activeSessions });
    }

    // Get all sessions from storage
    const sessions = await server.storageProvider.getAllSessions();

    res.status(200).json({ sessions });
  } catch (error) {
    console.error('Failed to get sessions:', error);
    res.status(500).json({ error: 'Failed to get sessions' });
  }
}

/**
 * Create a new session
 */
export async function createSession(req: Request, res: Response) {
  try {
    const server = req.app.locals.server;

    const sessionId = nanoid();

    // Pass custom AGIO provider if available
    const session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

    server.sessions[sessionId] = session;

    const { storageUnsubscribe } = await session.initialize();

    // Save unsubscribe function for cleanup
    if (storageUnsubscribe) {
      server.storageUnsubscribes[sessionId] = storageUnsubscribe;
    }

    // Store session metadata if we have storage
    if (server.storageProvider) {
      const metadata: SessionMetadata = {
        id: sessionId,
        createdAt: Date.now(),
        updatedAt: Date.now(),
        workspace: server.getCurrentWorkspace(),
      };

      await server.storageProvider.createSession(metadata);
    }

    res.status(201).json({ sessionId });
  } catch (error) {
    console.error('Failed to create session:', error);
    res.status(500).json({ error: 'Failed to create session' });
  }
}

/**
 * Get session details
 */
export async function getSessionDetails(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    // Check storage first
    if (server.storageProvider) {
      const metadata = await server.storageProvider.getSessionMetadata(sessionId);
      if (metadata) {
        return res.status(200).json({
          session: metadata,
        });
      }
    }

    return res.status(404).json({ error: 'Session not found' });
  } catch (error) {
    console.error(\`Error getting session details for \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to get session details' });
  }
}

/**
 * Get session events
 */
export async function getSessionEvents(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      return res.status(404).json({ error: 'Storage not configured, no events available' });
    }

    const events = await server.storageProvider.getSessionEvents(sessionId);
    res.status(200).json({ events });
  } catch (error) {
    console.error(\`Error getting events for session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to get session events' });
  }
}

/**
 * Get session status
 */
export async function getSessionStatus(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const session = req.session as AgentSession;

    const isProcessing = session.getProcessingStatus();

    res.status(200).json({
      sessionId,
      status: {
        isProcessing,
        state: session.agent.status(),
      },
    });
  } catch (error) {
    console.error(\`Error getting session status (\${sessionId}):\`, error);
    res.status(500).json({ error: 'Failed to get session status' });
  }
}

/**
 * Update session metadata
 */
export async function updateSession(req: Request, res: Response) {
  const { sessionId, name, tags } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      return res.status(404).json({ error: 'Storage not configured, cannot update session' });
    }

    const metadata = await server.storageProvider.getSessionMetadata(sessionId);
    if (!metadata) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const updatedMetadata = await server.storageProvider.updateSessionMetadata(sessionId, {
      name,
      tags,
      updatedAt: Date.now(),
    });

    res.status(200).json({ session: updatedMetadata });
  } catch (error) {
    console.error(\`Error updating session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to update session' });
  }
}

/**
 * Delete a session
 */
export async function deleteSession(req: Request, res: Response) {
  const { sessionId } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;

    // Close active session if exists
    if (server.sessions[sessionId]) {
      // Before clearing the session, try dispose the agent first
      try {
        const agent = server.sessions[sessionId].agent;
        if (agent) {
          agent.dispose();
        }
      } catch (error) {
        console.warn(
          \`Failed to cleanup agent for session \${sessionId}: \${error instanceof Error ? error.message : String(error)}\`,
        );
      }

      await server.sessions[sessionId].cleanup();
      delete server.sessions[sessionId];

      // Clean up storage unsubscribe
      if (server.storageUnsubscribes[sessionId]) {
        server.storageUnsubscribes[sessionId]();
        delete server.storageUnsubscribes[sessionId];
      }
    }

    // Delete from storage if configured
    if (server.storageProvider) {
      const deleted = await server.storageProvider.deleteSession(sessionId);
      if (!deleted) {
        return res.status(404).json({ error: 'Session not found in storage' });
      }
    }

    res.status(200).json({ success: true });
  } catch (error) {
    console.error(\`Error deleting session \${sessionId}:\`, error);
    res.status(500).json({ error: 'Failed to delete session' });
  }
}

/**
 * Generate summary for a session
 */
export async function generateSummary(req: Request, res: Response) {
  const { sessionId, messages, model, provider } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  if (!Array.isArray(messages) || messages.length === 0) {
    return res.status(400).json({ error: 'Messages are required' });
  }

  try {
    const server = req.app.locals.server;
    const session = server.sessions[sessionId];

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // FIXME: Use smaller messages to generate summaries
    // Generate summary using the agent's method
    const summaryResponse = await session.agent.generateSummary({
      messages,
      model,
      provider,
    });

    // Return the summary
    res.status(200).json(summaryResponse);
  } catch (error) {
    console.error(\`Error generating summary for session \${sessionId}:\`, error);
    res.status(500).json({
      error: 'Failed to generate summary',
      message: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Share a session
 */
export async function shareSession(req: Request, res: Response) {
  const { sessionId, upload } = req.body;

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;
    const shareService = new ShareService(server.appConfig, server.storageProvider);

    // Get agent instance if session is active (for slug generation)
    const agent = server.sessions[sessionId]?.agent;
    const result = await shareService.shareSession(sessionId, upload, agent, server.versionInfo);
    if (result.success) {
      return res.status(200).json(result);
    } else {
      return res.status(500).json({
        error: result.error || 'Failed to share session',
      });
    }
  } catch (error) {
    console.error(\`Error sharing session \${sessionId}:\`, error);
    return res.status(500).json({ error: 'Failed to share session' });
  }
}

/**
 * Get events from the latest updated session
 */
export async function getLatestSessionEvents(req: Request, res: Response) {
  try {
    const server = req.app.locals.server;

    if (!server.storageProvider) {
      return res
        .status(404)
        .json({ error: 'Storage not configured, cannot get latest session events' });
    }

    // Get all sessions
    const sessions = await server.storageProvider.getAllSessions();

    if (sessions.length === 0) {
      return res.status(404).json({ error: 'No sessions found' });
    }

    // Find the session with the most recent updatedAt timestamp
    const latestSession = sessions.reduce((latest, current) => {
      return current.updatedAt > latest.updatedAt ? current : latest;
    });

    // Get events for the latest session
    const events = await server.storageProvider.getSessionEvents(latestSession.id);

    res.status(200).json({
      sessionId: latestSession.id,
      sessionMetadata: latestSession,
      events,
    });
  } catch (error) {
    console.error('Error getting latest session events:', error);
    res.status(500).json({ error: 'Failed to get latest session events' });
  }
}

/**
 * Get session workspace files
 */
export async function getSessionWorkspaceFiles(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;
  const requestPath = (req.query.path as string) || '/';

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  try {
    const server = req.app.locals.server;
    const session = server.sessions[sessionId];

    // Check if session exists (active or stored)
    if (!session && server.storageProvider) {
      const metadata = await server.storageProvider.getSessionMetadata(sessionId);
      if (!metadata) {
        return res.status(404).json({ error: 'Session not found' });
      }
    } else if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    const baseWorkspacePath = server.getCurrentWorkspace();

    // Build potential file paths
    const pathsToCheck: string[] = [];

    pathsToCheck.push(path.join(baseWorkspacePath, requestPath));

    // Find the first existing path
    let targetPath: string | null = null;
    for (const checkPath of pathsToCheck) {
      const normalizedPath = path.resolve(checkPath);
      const normalizedWorkspace = path.resolve(baseWorkspacePath);

      // Security check
      if (normalizedPath.startsWith(normalizedWorkspace) && fs.existsSync(normalizedPath)) {
        targetPath = normalizedPath;
        break;
      }
    }

    if (!targetPath) {
      return res.status(404).json({ error: 'Path not found' });
    }

    const stats = fs.statSync(targetPath);

    if (stats.isFile()) {
      // Return file info
      return res.json({
        type: 'file',
        name: path.basename(targetPath),
        size: stats.size,
        modified: stats.mtime,
        path: requestPath,
      });
    } else if (stats.isDirectory()) {
      // Return directory listing
      const files = fs.readdirSync(targetPath).map((file) => {
        const filePath = path.join(targetPath, file);
        const fileStats = fs.statSync(filePath);
        return {
          name: file,
          isDirectory: fileStats.isDirectory(),
          size: fileStats.size,
          modified: fileStats.mtime,
          path: path.join(requestPath, file).replace(/\\\\/g, '/'),
        };
      });

      return res.json({
        type: 'directory',
        path: requestPath,
        files: files.sort((a, b) => {
          if (a.isDirectory && !b.isDirectory) return -1;
          if (!a.isDirectory && b.isDirectory) return 1;
          return a.name.localeCompare(b.name);
        }),
      });
    }

    return res.status(400).json({ error: 'Invalid path type' });
  } catch (error) {
    console.error(\`Error accessing workspace files for session \${sessionId}:\`, error);
    res.status(500).json({
      error: 'Failed to access workspace files',
      message: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Search files and directories in session workspace
 */
export async function searchWorkspaceItems(req: Request, res: Response) {
  const sessionId = req.query.sessionId as string;
  const query = req.query.q as string;
  const type = req.query.type as 'file' | 'directory' | 'all';

  if (!sessionId) {
    return res.status(400).json({ error: 'Session ID is required' });
  }

  // Allow empty query for default directory listing
  if (query === undefined || query === null) {
    return res.status(400).json({ error: 'Search query parameter is required' });
  }

  try {
    const server = req.app.locals.server;
    const baseWorkspacePath = server.getCurrentWorkspace();

    let items: Array<{ name: string; path: string; type: 'file' | 'directory'; relativePath: string }>;

    if (query.length === 0) {
      // Empty query: return current directory contents (top-level files and directories)
      items = await getWorkspaceRootItems(baseWorkspacePath, type || 'all');
    } else {
      // Non-empty query: search recursively
      items = await searchWorkspaceItemsRecursive(baseWorkspacePath, query, type || 'all');
    }

    // Limit results to avoid overwhelming the UI
    const limitedItems = items.slice(0, 20);

    res.status(200).json({ items: limitedItems });
  } catch (error) {
    console.error(\`Error searching workspace items for session \${sessionId}:\`, error);
    res.status(500).json({
      error: 'Failed to search workspace items',
      message: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Recursively search for files and directories
 */
async function searchWorkspaceItemsRecursive(
  basePath: string,
  query: string,
  type: 'file' | 'directory' | 'all',
): Promise<
  Array<{ name: string; path: string; type: 'file' | 'directory'; relativePath: string }>
> {
  const items: Array<{
    name: string;
    path: string;
    type: 'file' | 'directory';
    relativePath: string;
  }> = [];

  const searchInDirectory = async (currentPath: string, depth = 0) => {
    // Limit recursion depth to avoid performance issues
    if (depth > 5) return;

    try {
      const entries = fs.readdirSync(currentPath);

      for (const entry of entries) {
        // Skip hidden files and common ignore patterns
        if (entry.startsWith('.') || entry === 'node_modules' || entry === '.git') {
          continue;
        }

        const fullPath = path.join(currentPath, entry);
        const stats = fs.statSync(fullPath);
        const relativePath = path.relative(basePath, fullPath);

        // Check if name matches query (case-insensitive)
        if (entry.toLowerCase().includes(query.toLowerCase())) {
          const itemType = stats.isDirectory() ? 'directory' : 'file';

          if (type === 'all' || type === itemType) {
            items.push({
              name: entry,
              path: fullPath,
              type: itemType,
              relativePath: relativePath.replace(/\\\\/g, '/'), // Normalize path separators
            });
          }
        }

        // Recursively search in subdirectories
        if (stats.isDirectory()) {
          await searchInDirectory(fullPath, depth + 1);
        }
      }
    } catch (error) {
      // Skip directories we can't read
      console.warn(\`Cannot read directory \${currentPath}:\`, error);
    }
  };

  await searchInDirectory(basePath);

  // Sort by type (directories first) then by name
  return items.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type === 'directory' ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });
}

/**
 * Get root level items in workspace
 */
async function getWorkspaceRootItems(
  basePath: string,
  type: 'file' | 'directory' | 'all',
): Promise<Array<{ name: string; path: string; type: 'file' | 'directory'; relativePath: string }>> {
  const items: Array<{
    name: string;
    path: string;
    type: 'file' | 'directory';
    relativePath: string;
  }> = [];

  try {
    const entries = fs.readdirSync(basePath);

    for (const entry of entries) {
      // Skip hidden files and common ignore patterns
      if (entry.startsWith('.') || entry === 'node_modules' || entry === '.git') {
        continue;
      }

      const fullPath = path.join(basePath, entry);
      const stats = fs.statSync(fullPath);
      const itemType = stats.isDirectory() ? 'directory' : 'file';

      if (type === 'all' || type === itemType) {
        items.push({
          name: entry,
          path: fullPath,
          type: itemType,
          relativePath: entry,
        });
      }
    }
  } catch (error) {
    console.warn(\`Cannot read directory \${basePath}:\`, error);
  }

  // Sort by type (directories first) then by name
  return items.sort((a, b) => {
    if (a.type !== b.type) {
      return a.type === 'directory' ? -1 : 1;
    }
    return a.name.localeCompare(b.name);
  });
}",
      "hasError": false,
      "relativePath": "src/api/controllers/sessions.ts",
      "size": 17975,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';
import { ShareService } from '../../services';

/**
 * Get share configuration
 */
export function getShareConfig(req: Request, res: Response) {
  const server = req.app.locals.server;
  const shareService = new ShareService(server.appConfig, server.storageProvider);
  res.status(200).json(shareService.getShareConfig());
}
",
      "hasError": false,
      "relativePath": "src/api/controllers/share.ts",
      "size": 475,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response } from 'express';

/**
 * Health check endpoint
 */
export function healthCheck(req: Request, res: Response) {
  res.status(200).json({ status: 'ok' });
}

/**
 * Get version information including git hash
 */
export function getVersion(req: Request, res: Response) {
  const server = req.app.locals.server;
  res.status(200).json({
    version: server.versionInfo?.version,
    buildTime: server.versionInfo?.buildTime,
    gitHash: server.versionInfo?.gitHash,
  });
}

/**
 * Get current agent information
 */
export function getAgentInfo(req: Request, res: Response) {
  const server = req.app.locals.server;
  res.status(200).json({
    name: server.getCurrentAgentName() || 'Unknown Agent',
  });
}
",
      "hasError": false,
      "relativePath": "src/api/controllers/system.ts",
      "size": 837,
    },
    {
      "content": "import express from 'express';
import cors from 'cors';
import { registerAllRoutes } from './routes';
import { setupWorkspaceStaticServer } from '../utils/workspace-static-server';

/**
 * Get default CORS options if none are provided
 *
 * TODO: support cors config.
 */
export function getDefaultCorsOptions(): cors.CorsOptions {
  return {
    origin: '*',
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization'],
  };
}

/**
 * Setup API middleware and routes
 * @param app Express application instance
 * @param options Server options
 */
export function setupAPI(
  app: express.Application,
  options?: {
    workspacePath?: string;
    isDebug?: boolean;
  },
) {
  // Apply CORS middleware
  app.use(cors(getDefaultCorsOptions()));

  // Apply JSON body parser middleware
  app.use(express.json({ limit: '20mb' }));

  // Add app.group method
  app.group = (
    prefix: string,
    ...handlers: (express.RequestHandler | ((router: express.Router) => void))[]
  ) => {
    const router = express.Router();
    const routerCallback = handlers.pop() as (router: express.Router) => void;
    const middlewares = handlers as express.RequestHandler[];

    routerCallback(router);
    app.use(prefix, ...middlewares, router);
  };

  // Register all API routes first (highest priority)
  registerAllRoutes(app);

  // Setup workspace static server (lower priority, after API routes)
  if (options?.workspacePath) {
    setupWorkspaceStaticServer(app, options.workspacePath, options.isDebug);
  }
}
",
      "hasError": false,
      "relativePath": "src/api/index.ts",
      "size": 1558,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export { sessionRestoreMiddleware } from './session-restore';
",
      "hasError": false,
      "relativePath": "src/api/middleware/index.ts",
      "size": 167,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Request, Response, NextFunction } from 'express';
import { getLogger } from '@tarko/shared-utils';
import { AgentServer } from '../../server';
import { AgentSession } from '../../core';

const logger = getLogger('SessionRestoreMiddleware');
/**
 * Session recovery middleware
 * If the session is not in memory but the storage is available, try to restore the session from storage
 */
export async function sessionRestoreMiddleware(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void | Response> {
  const server: AgentServer = req.app.locals.server;

  try {
    const sessionId = (req.query.sessionId as string) || (req.body.sessionId as string);

    if (!sessionId) {
      return res.status(400).json({ error: 'Session ID is required' });
    }

    let session = server.sessions[sessionId];

    // If the session is not in memory but the storage is available, try to restore the session from storage
    if (!session && server.storageProvider) {
      const metadata = await server.storageProvider.getSessionMetadata(sessionId);
      if (metadata) {
        try {
          // Recover sessions from storage using a custom AGIO provider
          session = new AgentSession(server, sessionId, server.getCustomAgioProvider());

          server.sessions[sessionId] = session;

          const { storageUnsubscribe } = await session.initialize();

          // Save unsubscribe function for cleaning
          if (storageUnsubscribe) {
            server.storageUnsubscribes[sessionId] = storageUnsubscribe;
          }

          logger.debug(\`Session \${sessionId} restored from storage\`);
        } catch (error) {
          logger.error(\`Failed to restore session \${sessionId}:\`, error);

          return res.status(200).json({
            sessionId,
            status: {
              isProcessing: false,
              state: 'stored', //Special state, indicating that the session exists in storage but is not activated
            },
          });
        }
      }
    }

    if (!session) {
      return res.status(404).json({ error: 'Session not found' });
    }

    // Mounted on req for subsequent reading
    req.session = session;

    next();
  } catch (error) {
    logger.error(\`Session restore middleware error: \${(error as Error).message}\`);
    return res.status(500).json({ error: \`Internal server error, \${(error as Error).message}\` });
  }
}
",
      "hasError": false,
      "relativePath": "src/api/middleware/session-restore.ts",
      "size": 2506,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import { registerSessionRoutes } from './sessions';
import { registerQueryRoutes } from './queries';
import { registerSystemRoutes } from './system';
import { registerShareRoutes } from './share';
import { registerOneshotRoutes } from './oneshot';

/**
 * Register all API routes with the Express application
 * @param app Express application
 */
export function registerAllRoutes(app: express.Application): void {
  registerSessionRoutes(app);
  registerQueryRoutes(app);
  registerSystemRoutes(app);
  registerShareRoutes(app);
  registerOneshotRoutes(app);
}
",
      "hasError": false,
      "relativePath": "src/api/routes/index.ts",
      "size": 698,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as oneshotController from '../controllers/oneshot';

/**
 * Register one-shot query routes (create session and execute query in one step)
 * @param app Express application
 */
export function registerOneshotRoutes(app: express.Application): void {
  // Create session and send a query (non-streaming)
  app.post('/api/v1/oneshot/query', oneshotController.createAndQuery);

  // Create session and send a streaming query
  app.post('/api/v1/oneshot/query/stream', oneshotController.createAndStreamingQuery);
}
",
      "hasError": false,
      "relativePath": "src/api/routes/oneshot.ts",
      "size": 654,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as queriesController from '../controllers/queries';
import { sessionRestoreMiddleware } from '../middleware';

/**
 * Register query execution routes
 * @param app Express application
 */
export function registerQueryRoutes(app: express.Application): void {
  app.group('/api/v1/sessions', [sessionRestoreMiddleware], (router: express.Router) => {
    // Send a query (non-streaming)
    router.post('/query', queriesController.executeQuery);
    // Send a streaming query
    router.post('/query/stream', queriesController.executeStreamingQuery);
    // Abort a running query
    router.post('/abort', queriesController.abortQuery);
  });
}
",
      "hasError": false,
      "relativePath": "src/api/routes/queries.ts",
      "size": 787,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as sessionsController from '../controllers/sessions';
import { sessionRestoreMiddleware } from '../middleware';

/**
 * Register session management routes
 * @param app Express application
 */
export function registerSessionRoutes(app: express.Application): void {
  app.group('/api/v1/sessions', (router: express.Router) => {
    // Get all sessions
    router.get('/', sessionsController.getAllSessions);
    // Create a new session
    router.post('/create', sessionsController.createSession);
  });

  app.group('/api/v1/sessions', [sessionRestoreMiddleware], (router: express.Router) => {
    // Get session details
    router.get('/details', sessionsController.getSessionDetails);
    // Get session events
    router.get('/events', sessionsController.getSessionEvents);
    // Get latest session events
    router.get('/events/latest', sessionsController.getLatestSessionEvents);
    // Get session status
    router.get('/status', sessionsController.getSessionStatus);
    // Update session metadata
    router.post('/update', sessionsController.updateSession);
    // Delete a session
    router.post('/delete', sessionsController.deleteSession);
    // Generate summary for a session
    router.post('/generate-summary', sessionsController.generateSummary);
    // Share a session
    router.post('/share', sessionsController.shareSession);
    // Get session workspace files
    router.get('/workspace/files', sessionsController.getSessionWorkspaceFiles);
    // Search workspace items for contextual selector
    router.get('/workspace/search', sessionsController.searchWorkspaceItems);
  });
}",
      "hasError": false,
      "relativePath": "src/api/routes/sessions.ts",
      "size": 1751,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as shareController from '../controllers/share';

/**
 * Register sharing-related routes
 * @param app Express application
 */
export function registerShareRoutes(app: express.Application): void {
  // Get share configuration
  app.get('/api/v1/share/config', shareController.getShareConfig);
}
",
      "hasError": false,
      "relativePath": "src/api/routes/share.ts",
      "size": 439,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import * as systemController from '../controllers/system';

/**
 * Register system information routes
 * @param app Express application
 */
export function registerSystemRoutes(app: express.Application): void {
  // Health check endpoint
  app.get('/api/v1/health', systemController.healthCheck);

  // Version information endpoint
  app.get('/api/v1/version', systemController.getVersion);

  // Agent information endpoint
  app.get('/api/v1/agent', systemController.getAgentInfo);
}
",
      "hasError": false,
      "relativePath": "src/api/routes/system.ts",
      "size": 621,
    },
    {
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import path from 'path';
import {
  AgentEventStream,
  AgentStatus,
  AgioProviderConstructor,
  ChatCompletionContentPart,
  IAgent,
} from '@tarko/interface';
import { AgentSnapshot } from '@tarko/agent-snapshot';
import { EventStreamBridge } from '../utils/event-stream';
import type { AgentServer } from '../server';
import { AgioEvent } from '@tarko/agio';
import { handleAgentError, ErrorWithCode } from '../utils/error-handler';

/**
 * Check if an event should be stored in persistent storage
 * Filters out streaming events that are only needed for real-time updates
 * but not for replay/sharing functionality
 */
function shouldStoreEvent(event: AgentEventStream.Event): boolean {
  // Filter out streaming events that cause performance issues during replay
  const streamingEventTypes: AgentEventStream.EventType[] = [
    'assistant_streaming_message',
    'assistant_streaming_thinking_message',
    'assistant_streaming_tool_call',
    'final_answer_streaming',
  ];

  return !streamingEventTypes.includes(event.type);
}

/**
 * Response type for agent query execution
 */
export interface AgentQueryResponse<T = any> {
  success: boolean;
  result?: T;
  error?: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
}

/**
 * AgentSession - Represents a single agent execution context
 *
 * Responsible for:
 * - Managing a generic Agent instance and its lifecycle
 * - Connecting agent events to clients via EventStreamBridge
 * - Handling queries and interactions with the agent
 * - Persisting events to storage
 * - Collecting AGIO monitoring events if configured
 */
export class AgentSession {
  id: string;
  agent: IAgent;
  eventBridge: EventStreamBridge;
  private unsubscribe: (() => void) | null = null;
  private agioProvider?: AgioEvent.AgioProvider;

  constructor(
    private server: AgentServer,
    sessionId: string,
    agioProviderImpl?: AgioProviderConstructor,
  ) {
    this.id = sessionId;
    this.eventBridge = new EventStreamBridge();

    // Get agent options from server
    const agentOptions = { ...server.appConfig };

    // Create agent instance using the server's factory method
    const agent = server.createAgent();

    // Initialize agent snapshot if enabled
    if (agentOptions.snapshot?.enable) {
      const snapshotStoragesDirectory =
        agentOptions.snapshot.storageDirectory ?? server.getCurrentWorkspace();

      if (snapshotStoragesDirectory) {
        const snapshotPath = path.join(snapshotStoragesDirectory, sessionId);
        // @ts-expect-error
        this.agent = new AgentSnapshot(agent, {
          snapshotPath,
          snapshotName: sessionId,
        }) as unknown as IAgent;

        // Log snapshot initialization if agent has logger
        if ('logger' in agent) {
          (agent as any).logger.debug(\`AgentSnapshot initialized with path: \${snapshotPath}\`);
        }
      } else {
        this.agent = agent;
      }
    } else {
      this.agent = agent;
    }

    // Initialize AGIO collector if provider URL is configured
    if (agentOptions.agio?.provider && agioProviderImpl) {
      const impl = agioProviderImpl;
      this.agioProvider = new impl(agentOptions.agio.provider, agentOptions, sessionId, this.agent);

      // Log AGIO initialization if agent has logger
      if ('logger' in this.agent) {
        (this.agent as any).logger.debug(
          \`AGIO collector initialized with provider: \${agentOptions.agio.provider}\`,
        );
      }
    }

    // Log agent configuration if agent has logger and getOptions method
    if ('logger' in this.agent && 'getOptions' in this.agent) {
      (this.agent as any).logger.info(
        'Agent Config',
        JSON.stringify((this.agent as any).getOptions(), null, 2),
      );
    }
  }

  /**
   * Get the current processing status of the agent
   * @returns Whether the agent is currently processing a request
   */
  getProcessingStatus(): boolean {
    return this.agent.status() === AgentStatus.EXECUTING;
  }

  async initialize() {
    await this.agent.initialize();

    // Send agent initialization event to AGIO if configured
    if (this.agioProvider) {
      try {
        await this.agioProvider.sendAgentInitialized();
      } catch (error) {
        console.error('Failed to send AGIO initialization event:', error);
      }
    }

    // Connect to agent's event stream manager
    const agentEventStream = this.agent.getEventStream();

    // Create an event handler that saves events to storage and processes AGIO events
    const handleEvent = async (event: AgentEventStream.Event) => {
      // If we have storage, save the event (filtered for performance)
      if (this.server.storageProvider && shouldStoreEvent(event)) {
        try {
          await this.server.storageProvider.saveEvent(this.id, event);
        } catch (error) {
          console.error(\`Failed to save event to storage: \${error}\`);
        }
      }

      // Process AGIO events if collector is configured
      if (this.agioProvider) {
        try {
          await this.agioProvider.processAgentEvent(event);
        } catch (error) {
          console.error('Failed to process AGIO event:', error);
        }
      }
    };

    // Subscribe to events for storage and AGIO processing
    const storageUnsubscribe = agentEventStream.subscribe(handleEvent);

    // Connect to event bridge for client communication
    this.unsubscribe = this.eventBridge.connectToAgentEventStream(agentEventStream);

    // Notify client that session is ready
    this.eventBridge.emit('ready', { sessionId: this.id });

    return { storageUnsubscribe };
  }

  /**
   * Run a query and return a strongly-typed response
   * This version captures errors and returns structured response objects
   * @param query The query to process
   * @returns Structured response with success/error information
   */
  async runQuery(query: string | ChatCompletionContentPart[]): Promise<AgentQueryResponse> {
    try {
      // Run agent to process the query
      const result = await this.agent.run({
        input: query,
      });
      return {
        success: true,
        result,
      };
    } catch (error) {
      // Emit error event but don't throw
      this.eventBridge.emit('error', {
        message: error instanceof Error ? error.message : String(error),
      });

      // Handle error and return structured response
      const handledError = handleAgentError(error, \`Session \${this.id}\`);

      return {
        success: false,
        error: {
          code: handledError.code,
          message: handledError.message,
          details: handledError.details,
        },
      };
    }
  }

  /**
   * Execute a streaming query with robust error handling
   * @param query The query to process in streaming mode
   * @returns AsyncIterable of events or error response
   */
  async runQueryStreaming(
    query: string | ChatCompletionContentPart[],
  ): Promise<AsyncIterable<AgentEventStream.Event>> {
    try {
      // Run agent in streaming mode
      return await this.agent.run({
        input: query,
        stream: true,
      });
    } catch (error) {
      // Emit error event
      this.eventBridge.emit('error', {
        message: error instanceof Error ? error.message : String(error),
      });

      // Handle error and return a synthetic event stream with the error
      const handledError = handleAgentError(error, \`Session \${this.id} (streaming)\`);

      // Create a synthetic event stream that yields just an error event
      return this.createErrorEventStream(handledError);
    }
  }

  /**
   * Create a synthetic event stream containing an error event
   * This allows streaming endpoints to handle errors gracefully
   */
  private async *createErrorEventStream(
    error: ErrorWithCode,
  ): AsyncIterable<AgentEventStream.Event> {
    yield this.agent.getEventStream().createEvent('system', {
      level: 'error',
      message: error.message,
      details: {
        errorCode: error.code,
        details: error.details,
      },
    });
  }

  /**
   * Abort the currently running query
   * @returns True if the agent was running and aborted successfully
   */
  async abortQuery(): Promise<boolean> {
    try {
      const aborted = this.agent.abort();
      if (aborted) {
        this.eventBridge.emit('aborted', { sessionId: this.id });
      }
      return aborted;
    } catch (error) {
      this.eventBridge.emit('error', {
        message: error instanceof Error ? error.message : String(error),
      });
      return false;
    }
  }

  async cleanup() {
    // Unsubscribe from event stream
    if (this.unsubscribe) {
      this.unsubscribe();
      this.unsubscribe = null;
    }

    // Clean up agent resources
    await this.agent.dispose();

    if (this.agioProvider) {
      // This ensures that all buffered analytics events are sent before the session is terminated.
      await this.agioProvider.cleanup?.();
    }

    this.eventBridge.emit('closed', { sessionId: this.id });
  }
}

export default AgentSession;
",
      "hasError": false,
      "relativePath": "src/core/AgentSession.ts",
      "size": 9222,
    },
    {
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { Socket } from 'socket.io';
import { Server as SocketIOServer } from 'socket.io';
import http from 'http';
import { AgentServer } from '../server';
import { handleAgentError } from '../utils/error-handler';

/**
 * Setup WebSocket functionality for the server
 * @param httpServer HTTP server instance
 * @param server AgentServer instance
 * @returns Configured Socket.IO server
 */
export function setupSocketIO(httpServer: http.Server, server: AgentServer): SocketIOServer {
  const io = new SocketIOServer(httpServer, {
    cors: {
      origin: '*',
      methods: ['GET', 'POST'],
    },
  });

  // Register connection handler
  io.on('connection', (socket) => {
    SocketHandlers.handleConnection(socket, server);
  });

  return io;
}

/**
 * SocketHandlers - Event handlers for WebSocket connections
 *
 * Manages all socket events including:
 * - Connection/disconnection
 * - Session joining
 * - Query sending
 * - Query aborting
 */
export class SocketHandlers {
  /**
   * Handle client connection
   */
  static handleConnection(socket: Socket, server: AgentServer) {
    console.log('Client connected:', socket.id);

    // Register event handlers
    socket.on('ping', (callback) => {
      if (typeof callback === 'function') {
        callback();
      }
    });

    socket.on('join-session', (sessionId) => {
      SocketHandlers.handleJoinSession(socket, server, sessionId);
    });

    socket.on('send-query', async ({ sessionId, query }) => {
      await SocketHandlers.handleSendQuery(socket, server, sessionId, query);
    });

    socket.on('abort-query', async ({ sessionId }) => {
      await SocketHandlers.handleAbortQuery(socket, server, sessionId);
    });

    socket.on('disconnect', () => {
      console.log('Client disconnected:', socket.id);
    });
  }

  /**
   * Handle session joining
   */
  static handleJoinSession(socket: Socket, server: AgentServer, sessionId: string) {
    if (server.sessions[sessionId]) {
      socket.join(sessionId);
      console.log(\`Client \${socket.id} joined session \${sessionId}\`);

      // Subscribe to session's event stream
      const eventHandler = (eventType: string, data: any) => {
        socket.emit('agent-event', { type: eventType, data });
      };

      // Send initial status update immediately after joining
      const initialStatus = {
        isProcessing: server.sessions[sessionId].getProcessingStatus(),
        state: server.sessions[sessionId].agent.status(),
      };
      socket.emit('agent-status', initialStatus);

      server.sessions[sessionId].eventBridge.subscribe(eventHandler);

      socket.on('disconnect', () => {
        if (server.sessions[sessionId]) {
          server.sessions[sessionId].eventBridge.unsubscribe(eventHandler);
        }
      });
    } else {
      socket.emit('error', 'Session not found');
    }
  }

  /**
   * Handle sending a query
   */
  static async handleSendQuery(
    socket: Socket,
    server: AgentServer,
    sessionId: string,
    query: string,
  ) {
    if (server.sessions[sessionId]) {
      try {
        // Use enhanced error handling in runQuery
        const response = await server.sessions[sessionId].runQuery(query);

        if (!response.success && response.error) {
          socket.emit('error', response.error.message);
        }
      } catch (error) {
        // This should never happen with the new error handling
        const handledError = handleAgentError(error);
        console.error('Unexpected error in socket query:', handledError);
        socket.emit('error', handledError.message);
      }
    } else {
      socket.emit('error', 'Session not found');
    }
  }

  /**
   * Handle aborting a query
   */
  static async handleAbortQuery(socket: Socket, server: AgentServer, sessionId: string) {
    if (server.sessions[sessionId]) {
      try {
        const aborted = await server.sessions[sessionId].abortQuery();
        socket.emit('abort-result', { success: aborted });
      } catch (error) {
        console.error('Error aborting query:', error);
        socket.emit('error', 'Failed to abort query');
      }
    } else {
      socket.emit('error', 'Session not found');
    }
  }
}
",
      "hasError": false,
      "relativePath": "src/core/SocketHandlers.ts",
      "size": 4348,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './AgentSession';
export * from './SocketHandlers';
",
      "hasError": false,
      "relativePath": "src/core/index.ts",
      "size": 171,
    },
    {
      "content": "import 'express';
import { AgentServer } from './server';
import { AgentSession } from './core';

declare global {
  namespace Express {
    interface Locals {
      server: AgentServer;
    }

    interface Request {
      session?: AgentSession;
    }

    interface Application {
      group(
        prefix: string,
        ...handlers: (express.RequestHandler | ((router: express.Router) => void))[]
      ): void;
    }
  }
}
",
      "hasError": false,
      "relativePath": "src/express.d.ts",
      "size": 432,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './core';
export * from './server';
export * from './utils';
export * from './storage';
export * from './types';
export * from './services';
",
      "hasError": false,
      "relativePath": "src/index.ts",
      "size": 260,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import http from 'http';
import { Server as SocketIOServer } from 'socket.io';
import { setupAPI } from './api';
import { LogLevel } from '@tarko/interface';
import { StorageProvider, createStorageProvider } from './storage';
import { setupSocketIO } from './core/SocketHandlers';
import type { AgentSession } from './core';
import { resolveAgentImplementation } from './utils/agent-resolver';
import type {
  AgentServerVersionInfo,
  AgentServerInitOptions,
  AgentAppConfig,
  AgentResolutionResult,
  AgioProviderConstructor,
  IAgent,
} from './types';
import { TARKO_CONSTANTS, GlobalDirectoryOptions } from '@tarko/interface';

export { express };

/**
 * AgentServer - Generic server class for any Agent implementation
 *
 * This class orchestrates all server components including:
 * - Express application and HTTP server
 * - API endpoints
 * - WebSocket communication
 * - Session management
 * - Storage integration
 * - AGIO monitoring integration
 * - Workspace static file serving
 * - Generic Agent dependency injection
 */
export class AgentServer<T extends AgentAppConfig = AgentAppConfig> {
  // Core server components
  private app: express.Application;
  private server: http.Server;
  private io: SocketIOServer; // Socket.IO server

  // Server state
  private isRunning = false;

  // Session management
  public sessions: Record<string, AgentSession> = {};
  public storageUnsubscribes: Record<string, () => void> = {};

  // Configuration
  public readonly port: number;
  public readonly isDebug: boolean;
  public readonly storageProvider: StorageProvider | null = null;
  public readonly appConfig: T;
  public readonly versionInfo?: AgentServerVersionInfo;
  public readonly directories: Required<GlobalDirectoryOptions>;

  // Current agent resolution, resolved before server started
  private currentAgentResolution?: AgentResolutionResult;

  // Server information

  constructor(instantiationOptions: AgentServerInitOptions<T>) {
    const { appConfig, versionInfo, directories } = instantiationOptions;

    // Store injected Agent constructor and options
    this.appConfig = appConfig;

    // Store version info
    this.versionInfo = versionInfo;

    // Initialize directories with defaults
    this.directories = {
      globalWorkspaceDir: directories?.globalWorkspaceDir || TARKO_CONSTANTS.GLOBAL_WORKSPACE_DIR,
    };

    // Extract server configuration from agent options
    this.port = appConfig.server?.port ?? 3000;
    this.isDebug = appConfig.logLevel === LogLevel.DEBUG;

    // Initialize Express app and HTTP server
    this.app = express();
    this.server = http.createServer(this.app);

    // Initialize storage if provided
    if (appConfig.server?.storage) {
      this.storageProvider = createStorageProvider(appConfig.server.storage);
    }

    // Setup API routes and middleware (includes workspace static server)
    setupAPI(this.app, {
      workspacePath: this.getCurrentWorkspace(),
      isDebug: this.isDebug,
    });

    // Setup WebSocket functionality
    this.io = setupSocketIO(this.server, this);

    // Make server instance available to request handlers
    this.app.locals.server = this;
  }

  /**
   * Get the custom AGIO provider if injected
   * @returns Custom AGIO provider or undefined
   */
  getCustomAgioProvider(): AgioProviderConstructor | undefined {
    return this.currentAgentResolution?.agioProviderConstructor;
  }

  /**
   * Get the label of current agent
   */
  getCurrentWorkspace(): string {
    if (!this.appConfig?.workspace) {
      throw new Error('Workspace not specified');
    }
    return this.appConfig.workspace;
  }

  /**
   * Get the label of current agent
   */
  getCurrentAgentName(): string | undefined {
    return this.currentAgentResolution?.agentName;
  }

  /**
   * Get the Express application instance
   * @returns Express application
   */
  getApp(): express.Application {
    return this.app;
  }

  /**
   * Get the HTTP server instance
   * @returns HTTP server
   */
  getHttpServer(): http.Server {
    return this.server;
  }

  /**
   * Get the Socket.IO server instance
   * @returns Socket.IO server
   */
  getSocketIOServer(): SocketIOServer {
    return this.io;
  }

  /**
   * Check if the server is currently running
   * @returns True if server is running
   */
  isServerRunning(): boolean {
    return this.isRunning;
  }

  /**
   * Get storage information if available
   * @returns Object containing storage type and path (if applicable)
   */
  getStorageInfo(): { type: string; path?: string } {
    if (!this.storageProvider) {
      return { type: 'none' };
    }

    if (this.storageProvider.constructor.name === 'FileStorageProvider') {
      return {
        type: 'file',
        path: this.storageProvider.dbPath,
      };
    }

    if (this.storageProvider.constructor.name === 'SQLiteStorageProvider') {
      return {
        type: 'sqlite',
        path: this.storageProvider.dbPath,
      };
    }

    // For other storage types
    return {
      type: this.storageProvider.constructor.name.replace('StorageProvider', '').toLowerCase(),
    };
  }

  /**
   * Start the server on the configured port
   * @returns Promise resolving with the server instance
   */
  async start(): Promise<http.Server> {
    // Resolve agent implementation with workspace context
    const agentResolutionResult = await resolveAgentImplementation(this.appConfig.agent, {
      workspace: this.appConfig.workspace,
    });
    this.currentAgentResolution = agentResolutionResult;

    // Initialize storage if available
    if (this.storageProvider) {
      try {
        await this.storageProvider.initialize();
      } catch (error) {
        console.error('Failed to initialize storage provider:', error);
      }
    }

    return new Promise((resolve) => {
      this.server.listen(this.port, () => {
        this.isRunning = true;
        resolve(this.server);
      });
    });
  }

  /**
   * Stop the server and clean up all resources
   * @returns Promise resolving when server is stopped
   */
  async stop(): Promise<void> {
    // Clean up all active sessions
    const sessionCleanup = Object.values(this.sessions).map((session) => session.cleanup());
    await Promise.all(sessionCleanup);

    // Clean up all storage unsubscribes
    Object.values(this.storageUnsubscribes).forEach((unsubscribe) => unsubscribe());
    this.storageUnsubscribes = {};

    // Clear sessions
    this.sessions = {};

    // Close storage provider
    if (this.storageProvider) {
      await this.storageProvider.close();
    }

    // Close server if running
    if (this.isRunning) {
      return new Promise((resolve, reject) => {
        this.server.close((err) => {
          if (err) {
            reject(err);
            return;
          }

          this.isRunning = false;
          resolve();
        });
      });
    }

    return Promise.resolve();
  }

  /**
   * Create a new Agent instance using the injected constructor
   * @returns New Agent instance
   */
  createAgent(): IAgent {
    if (!this.currentAgentResolution) {
      throw new Error('Cannot found availble resolved agent');
    }
    return new this.currentAgentResolution.agentConstructor(this.appConfig);
  }
}
",
      "hasError": false,
      "relativePath": "src/server.ts",
      "size": 7382,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import crypto from 'crypto';
import { AgentEventStream, isAgentWebUIImplementationType } from '@tarko/interface';
import { SessionMetadata, StorageProvider } from '../storage';
import { ShareUtils } from '../utils/share';
import { SlugGenerator } from '../utils/slug-generator';
import fs from 'fs';
import path from 'path';
import { ensureHttps } from '../utils';
import type { AgentServerVersionInfo, IAgent, AgentAppConfig } from '../types';

/**
 * ShareService - Centralized service for handling session sharing
 *
 * Responsible for:
 * - Generating shareable HTML content
 * - Uploading shared content to providers
 * - Managing share metadata and slugs
 * - Processing and uploading workspace images
 */
export class ShareService {
  constructor(
    private appConfig: AgentAppConfig,
    private storageProvider: StorageProvider | null,
  ) {}

  /**
   * Share a session
   * @param sessionId Session ID to share
   * @param upload Whether to upload to share provider
   * @param agent Optional agent instance for slug generation
   * @param serverInfo Optional server version info
   * @returns Share result with URL or HTML content
   */
  async shareSession(
    sessionId: string,
    upload = false,
    agent?: IAgent,
    serverInfo?: AgentServerVersionInfo,
  ): Promise<{
    success: boolean;
    url?: string;
    html?: string;
    sessionId: string;
    error?: string;
  }> {
    try {
      // Verify storage is available
      if (!this.storageProvider) {
        throw new Error('Storage not configured, cannot share session');
      }

      // Get session metadata
      const metadata = await this.storageProvider.getSessionMetadata(sessionId);
      if (!metadata) {
        throw new Error('Session not found');
      }

      // Get session events
      const events = await this.storageProvider.getSessionEvents(sessionId);

      // Filter key frame events, exclude streaming messages
      const keyFrameEvents = events.filter(
        (event) =>
          event.type !== 'assistant_streaming_message' &&
          event.type !== 'assistant_streaming_thinking_message' &&
          event.type !== 'final_answer_streaming',
      );

      // Generate HTML content with server options
      let processedEvents = keyFrameEvents;
      if (upload && this.appConfig.share?.provider) {
        // @ts-expect-error
        processedEvents = await this.processWorkspaceImages(keyFrameEvents, metadata.workspace);
      }

      // Generate HTML content
      const shareHtml = this.generateShareHtml(keyFrameEvents, metadata, serverInfo);

      // Upload if requested and provider is configured
      if (upload && this.appConfig.share?.provider) {
        const shareUrl = await this.uploadShareHtml(shareHtml, sessionId, metadata, agent);
        return {
          success: true,
          url: shareUrl,
          sessionId,
        };
      }

      // Return HTML content if not uploading
      return {
        success: true,
        html: shareHtml,
        sessionId,
      };
    } catch (error) {
      return {
        success: false,
        sessionId,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }

  /**
   * Process workspace images in events and replace relative paths with uploaded URLs
   */
  private async processWorkspaceImages(
    events: AgentEventStream.Event[],
    workspace: string,
  ): Promise<AgentEventStream.Event[]> {
    if (!this.appConfig.share?.provider) {
      return events;
    }

    const processedEvents = [...events];
    const imageCache = new Map<string, string>(); // Cache to avoid duplicate uploads

    for (let i = 0; i < processedEvents.length; i++) {
      const event = processedEvents[i];

      // Process different event types that might contain file references
      if (event.type === 'tool_call' && event.name === 'write_file') {
        // Check write_file tool results for image references
        processedEvents[i] = await this.processEventImages(event, workspace, imageCache);
      }
    }

    return processedEvents;
  }

  /**
   * Process images in a single event
   */
  private async processEventImages(
    event: AgentEventStream.Event,
    workspace: string,
    imageCache: Map<string, string>,
  ): Promise<AgentEventStream.Event> {
    console.log('processEventImages');

    let content = '';

    // Extract content based on event type
    if (event.type === 'tool_call' && event.name === 'write_file') {
      content = event.arguments.content;
    } else {
      return event; // No processable content
    }

    // Find relative image paths in content
    const imageMatches = this.findImageReferences(content);
    if (imageMatches.length === 0) {
      return event;
    }

    let processedContent = content;

    // Process each image reference
    for (const match of imageMatches) {
      const { fullMatch, relativePath } = match;

      // Skip if already cached
      if (imageCache.has(relativePath)) {
        const uploadedUrl = imageCache.get(relativePath)!;
        processedContent = processedContent.replace(
          fullMatch,
          fullMatch.replace(relativePath, uploadedUrl),
        );
        continue;
      }

      try {
        // Resolve absolute path
        const absolutePath = path.resolve(workspace, relativePath);

        // Check if file exists and is an image
        if (fs.existsSync(absolutePath) && this.isImageFile(absolutePath)) {
          // Upload the image
          const uploadedUrl = await this.uploadWorkspaceImage(absolutePath, relativePath);

          // Cache the result
          imageCache.set(relativePath, uploadedUrl);

          // Replace in content
          processedContent = processedContent.replace(
            fullMatch,
            fullMatch.replace(relativePath, uploadedUrl),
          );
        }
      } catch (error) {
        console.warn(\`Failed to upload workspace image \${relativePath}:\`, error);
        // Continue with original path if upload fails
      }
    }

    // Return updated event
    const updatedEvent = { ...event };
    if (event.type === 'tool_call' && event.name === 'write_file') {
      updatedEvent.arguments.content = processedContent;
    }

    return updatedEvent;
  }

  /**
   * Find image references in content
   */
  private findImageReferences(content: string): Array<{ fullMatch: string; relativePath: string }> {
    const imageReferences: Array<{ fullMatch: string; relativePath: string }> = [];

    // Patterns to match relative image paths
    const patterns = [
      // Markdown images: ![alt](./path/to/image.jpg)
      /!\\[([^\\]]*)\\]\\(\\.\\/([^)]+\\.(jpg|jpeg|png|gif|webp|svg))\\)/gi,
      /!\\[([^\\]]*)\\]\\(([^\\/][^)]+\\.(jpg|jpeg|png|gif|webp|svg))\\)/gi,
      // HTML img tags: <img src="./path/to/image.jpg">
      /<img[^>]+src=["']\\.\\/([^"']+\\.(jpg|jpeg|png|gif|webp|svg))["'][^>]*>/gi,
      /<img[^>]+src=["']([^\\/][^"']+\\.(jpg|jpeg|png|gif|webp|svg))["'][^>]*>/gi,
      // Direct file references in code blocks or text
      /(?:^|\\s)(\\.\\/[^\\s]+\\.(jpg|jpeg|png|gif|webp|svg))(?:\\s|$)/gi,
      /(?:^|\\s)([^\\/\\s][^\\s]*\\.(jpg|jpeg|png|gif|webp|svg))(?:\\s|$)/gi,
    ];

    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(content)) !== null) {
        const fullMatch = match[0];
        // Extract the relative path from different capture groups based on pattern
        let relativePath = '';

        if (match[2] && match[2].includes('.')) {
          // For patterns with capture group 2 containing the path
          relativePath = match[2];
        } else if (match[1] && match[1].includes('.')) {
          // For patterns with capture group 1 containing the path
          relativePath = match[1];
        }

        if (relativePath && !relativePath.startsWith('http') && !relativePath.startsWith('data:')) {
          // Normalize relative path
          if (relativePath.startsWith('./')) {
            relativePath = relativePath.slice(2);
          }

          imageReferences.push({
            fullMatch,
            relativePath,
          });
        }
      }
    }

    return imageReferences;
  }

  /**
   * Check if file is an image based on extension
   */
  private isImageFile(filePath: string): boolean {
    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg'];
    const ext = path.extname(filePath).toLowerCase();
    return imageExtensions.includes(ext);
  }

  /**
   * Upload a workspace image to share provider
   */
  private async uploadWorkspaceImage(absolutePath: string, relativePath: string): Promise<string> {
    if (!this.appConfig.share?.provider) {
      throw new Error('Share provider not configured');
    }

    const fileName = path.basename(relativePath);
    const fileContent = fs.readFileSync(absolutePath);

    // Create form data for image upload
    const formData = new FormData();
    const file = new File([fileContent], fileName, {
      type: this.getImageMimeType(absolutePath),
    });

    formData.append('file', file);
    formData.append('type', 'image');
    formData.append('originalPath', relativePath);

    try {
      // FIXME: Support storage.provider
      const storageProvider = this.appConfig.share.provider.replace('/share', '/storage');

      const response = await fetch(storageProvider, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const responseData = await response.json();

      if (responseData) {
        if (responseData.cdnUrl) {
          return ensureHttps(responseData.cdnUrl);
        }

        if (responseData.url) {
          return ensureHttps(responseData.url);
        }
      }

      throw new Error('Invalid response from storage provider for image upload');
    } catch (error) {
      console.error(\`Failed to upload workspace image \${relativePath}:\`, error);
      throw error;
    }
  }

  /**
   * Get MIME type for image file
   */
  private getImageMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: Record<string, string> = {
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.svg': 'image/svg+xml',
    };

    return mimeTypes[ext] || 'application/octet-stream';
  }

  /**
   * Generate shareable HTML content
   */

  private generateShareHtml(
    events: AgentEventStream.Event[],
    metadata: SessionMetadata,
    versionInfo?: AgentServerVersionInfo,
  ): string {
    if (isAgentWebUIImplementationType(this.appConfig.webui!, 'static')) {
      if (!this.appConfig.webui?.staticPath) {
        throw new Error('Cannot found static path.');
      }

      return ShareUtils.generateShareHtml(
        events,
        metadata,
        this.appConfig.webui.staticPath,
        versionInfo,
      );
    }

    // TODO: implement remote web ui
    throw new Error(\`Unsupported web ui type: \${this.appConfig.webui!.type}\`);
  }

  /**
   * Upload share HTML to provider
   */
  private async uploadShareHtml(
    html: string,
    sessionId: string,
    metadata: SessionMetadata,
    agent?: IAgent,
  ): Promise<string> {
    if (!this.appConfig.share?.provider) {
      throw new Error('Share provider not configured');
    }

    // Generate normalized slug if agent is available
    let normalizedSlug = '';
    let originalQuery = '';

    if (this.storageProvider && agent) {
      try {
        const events = await this.storageProvider.getSessionEvents(sessionId);
        const firstUserMessage = events.find((e) => e.type === 'user_message');

        if (firstUserMessage && firstUserMessage.content) {
          originalQuery =
            typeof firstUserMessage.content === 'string'
              ? firstUserMessage.content
              : firstUserMessage.content.find((c) => c.type === 'text')?.text || '';

          if (originalQuery) {
            const slugGenerator = new SlugGenerator(agent);
            normalizedSlug = await slugGenerator.generateSlug(originalQuery);

            // Additional safety check to ensure slug is URL-safe
            normalizedSlug = normalizedSlug.replace(/[^\\x00-\\x7F]+/g, '').replace(/[^\\w-]/g, '');
          }
        }
      } catch (error) {
        console.warn('Failed to extract query for normalized slug:', error);
      }
    }

    if (normalizedSlug) {
      // Generate 6-digit hash from sessionId to avoid conflicts
      const sessionHash = await this.generateSessionHash(sessionId);
      normalizedSlug = \`\${normalizedSlug}-\${sessionHash}\`;
    } else {
      // fallback to sessionId
      normalizedSlug = sessionId;
    }

    return ShareUtils.uploadShareHtml(html, sessionId, this.appConfig.share?.provider as string, {
      metadata,
      slug: normalizedSlug,
      query: originalQuery,
    });
  }

  /**
   * Generate 6-digit hash from sessionId (Cloudflare Worker compatible)
   */
  private async generateSessionHash(sessionId: string): Promise<string> {
    const encoder = new TextEncoder();
    const data = encoder.encode(sessionId);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('')
      .slice(0, 6);
  }

  /**
   * Get share configuration
   */
  getShareConfig(): {
    hasShareProvider: boolean;
    shareProvider: string | null;
  } {
    return {
      hasShareProvider: !!this.appConfig.share?.provider,
      shareProvider: this.appConfig.share?.provider || null,
    };
  }
}
",
      "hasError": false,
      "relativePath": "src/services/ShareService.ts",
      "size": 13812,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './ShareService';
",
      "hasError": false,
      "relativePath": "src/services/index.ts",
      "size": 137,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream, AgentStorageImplementation } from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

/**
 * Abstract database storage provider
 * Base class for implementing database-specific storage providers
 * Extend this class to implement storage with MongoDB, PostgreSQL, etc.
 */
export abstract class DatabaseStorageProvider implements StorageProvider {
  protected config: AgentStorageImplementation;

  constructor(config: AgentStorageImplementation) {
    this.config = config;
  }

  abstract initialize(): Promise<void>;
  abstract createSession(metadata: SessionMetadata): Promise<SessionMetadata>;
  abstract updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata>;
  abstract getSessionMetadata(sessionId: string): Promise<SessionMetadata | null>;
  abstract getAllSessions(): Promise<SessionMetadata[]>;
  abstract deleteSession(sessionId: string): Promise<boolean>;
  abstract saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void>;
  abstract getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]>;
  abstract close(): Promise<void>;
}
",
      "hasError": false,
      "relativePath": "src/storage/DatabaseStorageProvider.ts",
      "size": 1309,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import path from 'path';
import fs from 'fs';
import { Low } from 'lowdb';
import { JSONFile } from 'lowdb/node';
import {
  AgentEventStream,
  FileAgentStorageImplementation,
  getGlobalStorageDirectory,
  TARKO_CONSTANTS,
} from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

/**
 * Data structure for lowdb
 */
interface DbSchema {
  sessions: Record<string, SessionMetadata>;
  events: Record<string, AgentEventStream.Event[]>;
}

/**
 * File-based storage provider using lowdb
 * Stores data in a JSON file for persistence
 * Suitable for local development and small-scale deployments
 */
export class FileStorageProvider implements StorageProvider {
  private db: Low<DbSchema>;
  private initialized = false;
  public readonly dbPath: string;

  constructor(config: FileAgentStorageImplementation) {
    // Default to the user's home directory
    const baseDir = getGlobalStorageDirectory(config.baseDir);
    const fileName = config.fileName ?? TARKO_CONSTANTS.SESSION_DATA_JSON_NAME;

    // Create the directory if it doesn't exist
    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true });
    }

    this.dbPath = path.join(baseDir, fileName);
    const adapter = new JSONFile<DbSchema>(this.dbPath);
    this.db = new Low<DbSchema>(adapter, { sessions: {}, events: {} });
  }

  async initialize(): Promise<void> {
    if (!this.initialized) {
      try {
        await this.db.read();
        // Initialize if file was empty or new
        this.db.data = this.db.data || { sessions: {}, events: {} };
        this.initialized = true;
      } catch (error) {
        // If file doesn't exist or is invalid JSON, create a new one
        this.db.data = { sessions: {}, events: {} };
        await this.db.write();
        this.initialized = true;
      }
    }
  }

  async createSession(metadata: SessionMetadata): Promise<SessionMetadata> {
    await this.ensureInitialized();

    const sessionData = {
      ...metadata,
      createdAt: metadata.createdAt || Date.now(),
      updatedAt: metadata.updatedAt || Date.now(),
    };

    this.db.data.sessions[metadata.id] = sessionData;
    this.db.data.events[metadata.id] = [];

    await this.db.write();
    return sessionData;
  }

  async updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata> {
    await this.ensureInitialized();

    const session = this.db.data.sessions[sessionId];
    if (!session) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const updatedSession = {
      ...session,
      ...metadata,
      updatedAt: Date.now(),
    };

    this.db.data.sessions[sessionId] = updatedSession;
    await this.db.write();

    return updatedSession;
  }

  async getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
    await this.ensureInitialized();
    return this.db.data.sessions[sessionId] || null;
  }

  async getAllSessions(): Promise<SessionMetadata[]> {
    await this.ensureInitialized();
    return Object.values(this.db.data.sessions);
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    await this.ensureInitialized();

    if (!this.db.data.sessions[sessionId]) {
      return false;
    }

    delete this.db.data.sessions[sessionId];
    delete this.db.data.events[sessionId];

    await this.db.write();
    return true;
  }

  async saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void> {
    await this.ensureInitialized();

    if (!this.db.data.sessions[sessionId]) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    if (!this.db.data.events[sessionId]) {
      this.db.data.events[sessionId] = [];
    }

    this.db.data.events[sessionId].push(event);

    // Update session timestamp
    this.db.data.sessions[sessionId].updatedAt = Date.now();

    await this.db.write();
  }

  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {
    await this.ensureInitialized();

    if (!this.db.data.sessions[sessionId]) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    return this.db.data.events[sessionId] || [];
  }

  async close(): Promise<void> {
    // Make sure any pending writes are flushed
    if (this.initialized) {
      await this.db.write();
    }
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }
}
",
      "hasError": false,
      "relativePath": "src/storage/FileStorageProvider.ts",
      "size": 4584,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream } from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

/**
 * In-memory storage provider
 * Simple implementation that stores data in memory
 * Useful for testing and development
 * Note: Data will be lost when the server restarts
 */
export class MemoryStorageProvider implements StorageProvider {
  private sessions: Map<string, SessionMetadata> = new Map();
  private events: Map<string, AgentEventStream.Event[]> = new Map();

  async initialize(): Promise<void> {
    // No initialization needed for memory storage
  }

  async createSession(metadata: SessionMetadata): Promise<SessionMetadata> {
    this.sessions.set(metadata.id, {
      ...metadata,
      createdAt: metadata.createdAt || Date.now(),
      updatedAt: metadata.updatedAt || Date.now(),
    });
    this.events.set(metadata.id, []);
    return this.sessions.get(metadata.id)!;
  }

  async updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata> {
    const session = this.sessions.get(sessionId);
    if (!session) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const updatedSession = {
      ...session,
      ...metadata,
      updatedAt: Date.now(),
    };

    this.sessions.set(sessionId, updatedSession);
    return updatedSession;
  }

  async getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
    return this.sessions.get(sessionId) || null;
  }

  async getAllSessions(): Promise<SessionMetadata[]> {
    return Array.from(this.sessions.values());
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    const deleted = this.sessions.delete(sessionId);
    this.events.delete(sessionId);
    return deleted;
  }

  async saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void> {
    if (!this.sessions.has(sessionId)) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const sessionEvents = this.events.get(sessionId) || [];
    sessionEvents.push(event);
    this.events.set(sessionId, sessionEvents);

    // Update the session's updatedAt timestamp
    await this.updateSessionMetadata(sessionId, { updatedAt: Date.now() });
  }

  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {
    if (!this.sessions.has(sessionId)) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }
    return this.events.get(sessionId) || [];
  }

  async close(): Promise<void> {
    // No cleanup needed for memory storage
  }
}
",
      "hasError": false,
      "relativePath": "src/storage/MemoryStorageProvider.ts",
      "size": 2671,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import path from 'path';
import fs from 'fs';
import { DatabaseSync } from 'node:sqlite';
import {
  AgentEventStream,
  getGlobalStorageDirectory,
  SqliteAgentStorageImplementation,
  TARKO_CONSTANTS,
} from '@tarko/interface';
import { StorageProvider, SessionMetadata } from './types';

// Define row types for better type safety
interface SessionRow {
  id: string;
  createdAt: number;
  updatedAt: number;
  name: string | null;
  workspace: string;
  tags: string | null;
}

interface EventRow {
  id: number;
  sessionId: string;
  timestamp: number;
  eventData: string;
}

interface ExistsResult {
  existsFlag: number;
}

/**
 * SQLite-based storage provider using Node.js native SQLite
 * Provides high-performance, file-based storage using the built-in SQLite module
 * Optimized for handling large amounts of event data
 */
export class SQLiteStorageProvider implements StorageProvider {
  private db: DatabaseSync;
  private initialized = false;
  public readonly dbPath: string;

  constructor(config: SqliteAgentStorageImplementation) {
    // Default to the user's home directory
    const baseDir = getGlobalStorageDirectory(config.baseDir);
    const dbName = config.dbName ?? TARKO_CONSTANTS.SESSION_DATA_DB_NAME;

    // Create the directory if it doesn't exist
    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true });
    }

    this.dbPath = path.join(baseDir, dbName);
    this.db = new DatabaseSync(this.dbPath, { open: false });
  }

  async initialize(): Promise<void> {
    if (!this.initialized) {
      try {
        // Open the database
        this.db.open();

        // Enable WAL mode for better concurrent performance
        this.db.exec('PRAGMA journal_mode = WAL');

        // Check if we need to migrate from old schema
        await this.migrateIfNeeded();

        // Create sessions table with current schema
        this.db.exec(\`
          CREATE TABLE IF NOT EXISTS sessions (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workspace TEXT NOT NULL,
            tags TEXT
          )
        \`);

        // Create events table with foreign key to sessions
        this.db.exec(\`
          CREATE TABLE IF NOT EXISTS events (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            sessionId TEXT NOT NULL,
            timestamp INTEGER NOT NULL,
            eventData TEXT NOT NULL,
            FOREIGN KEY (sessionId) REFERENCES sessions (id) ON DELETE CASCADE
          )
        \`);

        // Create index on sessionId for faster queries
        this.db.exec(\`
          CREATE INDEX IF NOT EXISTS idx_events_sessionId ON events (sessionId)
        \`);

        // Enable foreign keys
        this.db.exec('PRAGMA foreign_keys = ON');

        this.initialized = true;
      } catch (error) {
        console.error('Failed to initialize SQLite database:', error);
        throw error;
      }
    }
  }

  /**
   * Check and migrate from old database schema if needed
   */
  private async migrateIfNeeded(): Promise<void> {
    try {
      // Check if sessions table exists and get its schema
      const tableInfoStmt = this.db.prepare(\`
        PRAGMA table_info(sessions)
      \`);

      const columns = tableInfoStmt.all() as Array<{
        cid: number;
        name: string;
        type: string;
        notnull: number;
        dflt_value: any;
        pk: number;
      }>;

      if (columns.length === 0) {
        // Table doesn't exist yet, no migration needed
        return;
      }

      // Check if we have the old 'workingDirectory' column instead of 'workspace'
      const hasWorkingDirectory = columns.some((col) => col.name === 'workingDirectory');
      const hasWorkspace = columns.some((col) => col.name === 'workspace');

      if (hasWorkingDirectory && !hasWorkspace) {
        console.log('Migrating database schema: renaming workingDirectory to workspace');

        // SQLite doesn't support column renaming directly in older versions
        // We need to create a new table and copy data
        this.db.exec(\`
          CREATE TABLE sessions_new (
            id TEXT PRIMARY KEY,
            createdAt INTEGER NOT NULL,
            updatedAt INTEGER NOT NULL,
            name TEXT,
            workspace TEXT NOT NULL,
            tags TEXT
          )
        \`);

        // Copy data from old table to new table
        this.db.exec(\`
          INSERT INTO sessions_new (id, createdAt, updatedAt, name, workspace, tags)
          SELECT id, createdAt, updatedAt, name, workingDirectory, tags
          FROM sessions
        \`);

        // Drop old table and rename new table
        this.db.exec('DROP TABLE sessions');
        this.db.exec('ALTER TABLE sessions_new RENAME TO sessions');

        console.log('Database schema migration completed successfully');
      }
    } catch (error) {
      console.error('Failed to migrate database schema:', error);
      throw new Error(
        \`Database migration failed: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async createSession(metadata: SessionMetadata): Promise<SessionMetadata> {
    await this.ensureInitialized();

    const sessionData = {
      ...metadata,
      createdAt: metadata.createdAt || Date.now(),
      updatedAt: metadata.updatedAt || Date.now(),
    };

    const tagsJson = sessionData.tags ? JSON.stringify(sessionData.tags) : null;

    try {
      const stmt = this.db.prepare(\`
        INSERT INTO sessions (id, createdAt, updatedAt, name, workspace, tags)
        VALUES (?, ?, ?, ?, ?, ?)
      \`);

      stmt.run(
        sessionData.id,
        sessionData.createdAt,
        sessionData.updatedAt,
        sessionData.name || null,
        sessionData.workspace,
        tagsJson,
      );
      return sessionData;
    } catch (error) {
      console.error(\`Failed to create session \${sessionData.id}:\`, error);
      throw new Error(
        \`Failed to create session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata> {
    await this.ensureInitialized();

    // First, get the current session data
    const session = await this.getSessionMetadata(sessionId);
    if (!session) {
      throw new Error(\`Session not found: \${sessionId}\`);
    }

    const updatedSession = {
      ...session,
      ...metadata,
      updatedAt: Date.now(),
    };

    try {
      const params: Array<string | number | null> = [];
      const setClauses: string[] = [];

      if (metadata.name !== undefined) {
        setClauses.push('name = ?');
        params.push(metadata.name || null);
      }

      if (metadata.workspace !== undefined) {
        setClauses.push('workspace = ?');
        params.push(metadata.workspace);
      }

      if (metadata.tags !== undefined) {
        setClauses.push('tags = ?');
        params.push(metadata.tags ? JSON.stringify(metadata.tags) : null);
      }

      // Always update the timestamp
      setClauses.push('updatedAt = ?');
      params.push(updatedSession.updatedAt);

      // Add the session ID for the WHERE clause
      params.push(sessionId);

      if (setClauses.length === 0) {
        return updatedSession; // Nothing to update
      }

      const updateQuery = \`
        UPDATE sessions
        SET \${setClauses.join(', ')}
        WHERE id = ?
      \`;

      const updateStmt = this.db.prepare(updateQuery);
      updateStmt.run(...params);

      return updatedSession;
    } catch (error) {
      console.error(\`Failed to update session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to update session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async getSessionMetadata(sessionId: string): Promise<SessionMetadata | null> {
    await this.ensureInitialized();

    try {
      const stmt = this.db.prepare(\`
        SELECT id, createdAt, updatedAt, name, workspace, tags
        FROM sessions
        WHERE id = ?
      \`);

      const row = stmt.get(sessionId) as SessionRow | undefined;

      if (!row) {
        return null;
      }

      return {
        id: row.id,
        createdAt: row.createdAt,
        updatedAt: row.updatedAt,
        name: row.name || undefined,
        workspace: row.workspace,
        tags: row.tags ? JSON.parse(row.tags) : undefined,
      };
    } catch (error) {
      console.error(\`Failed to get session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to get session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async getAllSessions(): Promise<SessionMetadata[]> {
    await this.ensureInitialized();

    try {
      const stmt = this.db.prepare(\`
        SELECT id, createdAt, updatedAt, name, workspace, tags
        FROM sessions
        ORDER BY updatedAt DESC
      \`);

      const rows = stmt.all() as unknown as SessionRow[];

      return rows.map((row) => ({
        id: row.id,
        createdAt: row.createdAt,
        updatedAt: row.updatedAt,
        name: row.name || undefined,
        workspace: row.workspace,
        tags: row.tags ? JSON.parse(row.tags) : undefined,
      }));
    } catch (error) {
      console.error('Failed to get all sessions:', error);
      throw new Error(
        \`Failed to get all sessions: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async deleteSession(sessionId: string): Promise<boolean> {
    await this.ensureInitialized();

    try {
      // Delete events first (though the foreign key would handle this)
      const deleteEventsStmt = this.db.prepare('DELETE FROM events WHERE sessionId = ?');
      deleteEventsStmt.run(sessionId);

      // Delete the session
      const deleteSessionStmt = this.db.prepare('DELETE FROM sessions WHERE id = ?');
      const result = deleteSessionStmt.run(sessionId);

      return result.changes > 0;
    } catch (error) {
      console.error(\`Failed to delete session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to delete session: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void> {
    await this.ensureInitialized();

    try {
      // Check if session exists
      const sessionExistsStmt = this.db.prepare(\`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      \`);

      const sessionExists = sessionExistsStmt.get(sessionId) as ExistsResult | undefined;
      if (!sessionExists || !sessionExists.existsFlag) {
        throw new Error(\`Session not found: \${sessionId}\`);
      }

      const timestamp = Date.now();
      const eventData = JSON.stringify(event);

      // Insert the event
      const insertEventStmt = this.db.prepare(\`
        INSERT INTO events (sessionId, timestamp, eventData)
        VALUES (?, ?, ?)
      \`);

      insertEventStmt.run(sessionId, timestamp, eventData);

      // Update session's updatedAt timestamp
      const updateSessionStmt = this.db.prepare(\`
        UPDATE sessions SET updatedAt = ? WHERE id = ?
      \`);

      updateSessionStmt.run(timestamp, sessionId);
    } catch (error) {
      console.error(\`Failed to save event for session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to save event: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]> {
    await this.ensureInitialized();

    try {
      const sessionExistsStmt = this.db.prepare(\`
        SELECT 1 as existsFlag FROM sessions WHERE id = ?
      \`);

      const sessionExists = sessionExistsStmt.get(sessionId) as ExistsResult | undefined;
      if (!sessionExists || !sessionExists.existsFlag) {
        throw new Error(\`Session not found: \${sessionId}\`);
      }

      const stmt = this.db.prepare(\`
        SELECT eventData
        FROM events
        WHERE sessionId = ?
        ORDER BY timestamp ASC, id ASC
      \`);

      const rows = stmt.all(sessionId) as unknown as { eventData: string }[];

      return rows.map((row) => {
        try {
          return JSON.parse(row.eventData) as AgentEventStream.Event;
        } catch (error) {
          console.error(\`Failed to parse event data: \${row.eventData}\`);
          return {
            type: 'system',
            message: 'Failed to parse event data',
            timestamp: Date.now(),
          } as AgentEventStream.Event;
        }
      });
    } catch (error) {
      console.error(\`Failed to get events for session \${sessionId}:\`, error);
      throw new Error(
        \`Failed to get session events: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  async close(): Promise<void> {
    if (this.db && this.db.isOpen) {
      this.db.close();
    }
  }

  private async ensureInitialized(): Promise<void> {
    if (!this.initialized) {
      await this.initialize();
    }
  }
}
",
      "hasError": false,
      "relativePath": "src/storage/SQLiteStorageProvider.ts",
      "size": 13245,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { StorageProvider } from './types';
import { MemoryStorageProvider } from './MemoryStorageProvider';
import { FileStorageProvider } from './FileStorageProvider';
import { SQLiteStorageProvider } from './SQLiteStorageProvider';
import { AgentStorageImplementation, TARKO_CONSTANTS } from '@tarko/interface';

export * from './types';

/**
 * Creates and returns a storage provider based on the options
 * @param options Storage configuration options
 */
export function createStorageProvider(options?: AgentStorageImplementation): StorageProvider {
  if (!options || options.type === 'memory') {
    return new MemoryStorageProvider();
  }

  if (options.type === 'file') {
    return new FileStorageProvider(options);
  }

  if (options.type === 'sqlite') {
    return new SQLiteStorageProvider(options);
  }

  if (options.type === 'database') {
    throw new Error('Database storage not implemented');
  }

  // @ts-expect-error intercept unexpected storage type
  throw new Error(\`Unknown storage type: \${options.type}\`);
}
",
      "hasError": false,
      "relativePath": "src/storage/index.ts",
      "size": 1139,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream } from '@tarko/interface';

/**
 * Session metadata interface
 */
export interface SessionMetadata {
  id: string;
  createdAt: number;
  updatedAt: number;
  name?: string;
  workspace: string;
  tags?: string[];
}

/**
 * Abstract storage provider interface
 * Provides methods for storing and retrieving session data
 */
export interface StorageProvider {
  /**
   * DB path.
   */
  dbPath?: string;

  /**
   * Initialize the storage provider
   */
  initialize(): Promise<void>;

  /**
   * Create a new session with metadata
   * @param metadata Session metadata
   */
  createSession(metadata: SessionMetadata): Promise<SessionMetadata>;

  /**
   * Update session metadata
   * @param sessionId Session ID
   * @param metadata Partial metadata to update
   */
  updateSessionMetadata(
    sessionId: string,
    metadata: Partial<Omit<SessionMetadata, 'id'>>,
  ): Promise<SessionMetadata>;

  /**
   * Get session metadata
   * @param sessionId Session ID
   */
  getSessionMetadata(sessionId: string): Promise<SessionMetadata | null>;

  /**
   * Get all sessions metadata
   */
  getAllSessions(): Promise<SessionMetadata[]>;

  /**
   * Delete a session and all its events
   * @param sessionId Session ID
   */
  deleteSession(sessionId: string): Promise<boolean>;

  /**
   * Save an event to a session
   * @param sessionId Session ID
   * @param event Event to save
   */
  saveEvent(sessionId: string, event: AgentEventStream.Event): Promise<void>;

  /**
   * Get all events for a session
   * @param sessionId Session ID
   */
  getSessionEvents(sessionId: string): Promise<AgentEventStream.Event[]>;

  /**
   * Close the storage provider
   */
  close(): Promise<void>;
}
",
      "hasError": false,
      "relativePath": "src/storage/types.ts",
      "size": 1825,
    },
    {
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */
import { AgentAppConfig, AgentServerVersionInfo, GlobalDirectoryOptions } from '@tarko/interface';

export * from '@tarko/interface';

/**
 * Agent Server instantiation configuration
 */
export interface AgentServerInitOptions<T extends AgentAppConfig = AgentAppConfig> {
  /**
   * Agent version info
   */
  versionInfo?: AgentServerVersionInfo;
  /**
   * Global directory configuration
   */
  directories?: GlobalDirectoryOptions;
  /**
   * Agent App configuration
   */
  appConfig: T;
}

/**
 * API response structure for errors
 */
export interface ErrorResponse {
  error: string;
  message?: string;
  code?: string;
  details?: Record<string, any>;
}

/**
 * API response structure for success with data
 */
export interface SuccessResponse<T> {
  success: true;
  data: T;
}

/**
 * Session status response
 */
export interface SessionStatusResponse {
  sessionId: string;
  status: {
    isProcessing: boolean;
    state: string;
  };
}

/**
 * Browser control information response
 */
export interface BrowserControlInfoResponse {
  mode: string;
  tools: string[];
}

/**
 * Share configuration response
 */
export interface ShareConfigResponse {
  hasShareProvider: boolean;
  shareProvider: string | null;
}

/**
 * Share result response
 */
export interface ShareResultResponse {
  success: boolean;
  url?: string;
  html?: string;
  sessionId?: string;
  error?: string;
}
",
      "hasError": false,
      "relativePath": "src/types.ts",
      "size": 1554,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  AgentImplementation,
  isAgentImplementationType,
  AgentResolutionResult,
  AgentConstructor,
} from '@tarko/interface';

/**
 * Options for agent implementation resolution
 */
interface AgentResolutionOptions {
  /**
   * Workspace directory path for resolving relative module paths
   */
  workspace?: string;
}

export async function resolveAgentImplementation(
  implementaion?: AgentImplementation,
  options?: AgentResolutionOptions,
): Promise<AgentResolutionResult> {
  if (!implementaion) {
    throw new Error(\`Missing agent implmentation\`);
  }

  if (isAgentImplementationType(implementaion, 'module')) {
    return {
      agentName: implementaion.label ?? implementaion.constructor.label ?? 'Anonymous',
      agentConstructor: implementaion.constructor,
      agioProviderConstructor: implementaion.agio,
    };
  }

  if (isAgentImplementationType(implementaion, 'modulePath')) {
    const agentModulePathIdentifier = implementaion.value;

    try {
      // Build resolve options with workspace path if provided
      const resolveOptions: { paths?: string[] } = {};
      if (options?.workspace) {
        resolveOptions.paths = [options.workspace];
      }

      // First, use require.resolve to validate module existence and get absolute path
      // This handles npm packages, relative paths, and directories more robustly
      // When workspace is provided, it will be used as the base path for relative imports
      const resolvedPath = require.resolve(agentModulePathIdentifier, resolveOptions);

      // Use the resolved absolute path for import to ensure consistency
      const agentModule = await import(resolvedPath);

      // Handle nested default exports (common in transpiled modules)
      let agentConstructor = agentModule.default as AgentConstructor;

      // Check for double default nesting (e.g., agentModule.default.default)
      if (
        agentConstructor &&
        typeof agentConstructor === 'object' &&
        'default' in agentConstructor
      ) {
        // @ts-expect-error
        agentConstructor = agentConstructor.default as AgentConstructor;
      }

      if (!agentConstructor || typeof agentConstructor !== 'function') {
        throw new Error(
          \`Invalid agent module at '\${agentModulePathIdentifier}': Must export an Agent constructor as default export.\`,
        );
      }

      return {
        agentName: implementaion.label ?? agentConstructor.label ?? 'Anonymous',
        agentConstructor,
        agioProviderConstructor: implementaion.agio,
      };
    } catch (error) {
      throw new Error(
        \`Failed to resolve agent module '\${agentModulePathIdentifier}': \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  throw new Error(\`Non-supported agent type: \${implementaion.type}\`);
}
",
      "hasError": false,
      "relativePath": "src/utils/agent-resolver.ts",
      "size": 2926,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * ErrorWithCode - Extended Error class with error code
 * Provides structured error information for better handling
 */
export class ErrorWithCode extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: Record<string, any>,
  ) {
    super(message);
    this.name = 'AgentError';
  }
}

/**
 * Safely handles agent errors to prevent process crashes
 * @param error The error to handle
 * @param context Additional context for logging
 * @returns Normalized error object
 */
export function handleAgentError(error: unknown, context?: string): ErrorWithCode {
  // Log the error with context
  console.error(\`Agent error\${context ? \` [\${context}]\` : ''}:\`, error);

  // Normalize to ErrorWithCode
  if (error instanceof ErrorWithCode) {
    return error;
  }

  // Create structured error from generic error
  if (error instanceof Error) {
    return new ErrorWithCode(error.message, 'AGENT_EXECUTION_ERROR', { stack: error.stack });
  }

  // Handle non-Error objects
  return new ErrorWithCode(
    typeof error === 'string' ? error : 'Unknown agent execution error',
    'UNKNOWN_ERROR',
    { originalError: error },
  );
}

/**
 * Error response structure for agent errors
 */
export interface AgentErrorResponse {
  success: false;
  error: {
    code: string;
    message: string;
    details?: Record<string, any>;
  };
}

/**
 * Creates a standardized error response
 */
export function createErrorResponse(error: unknown): AgentErrorResponse {
  const normalizedError = handleAgentError(error);

  return {
    success: false,
    error: {
      code: normalizedError.code,
      message: normalizedError.message,
      details: normalizedError.details,
    },
  };
}
",
      "hasError": false,
      "relativePath": "src/utils/error-handler.ts",
      "size": 1829,
    },
    {
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { AgentEventStream } from '@tarko/interface';

/**
 * Implement event stream bridging to forward Agent's native events to the client
 */
export class EventStreamBridge {
  private subscribers: Set<(type: string, data: any) => void> = new Set();

  /**
   * Subscribe to events
   * @param handler event processing function
   */
  subscribe(handler: (type: string, data: any) => void): void {
    this.subscribers.add(handler);
  }

  /**
   * Unsubscribe event
   * @param handler event processing function
   */
  unsubscribe(handler: (type: string, data: any) => void): void {
    this.subscribers.delete(handler);
  }

  /**
   * Publish event
   * @param type event type
   * @param data event data
   */
  emit(type: string, data: any): void {
    for (const handler of this.subscribers) {
      handler(type, data);
    }
  }

  /**
   * Event stream manager connected to Agent
   * @param agentEventStream Agent's event stream manager
   * @returns Unsubscribe function
   */
  connectToAgentEventStream(agentEventStream: AgentEventStream.Processor): () => void {
    const handleEvent = (event: AgentEventStream.Event) => {
      // Mapping event types to socket.io-friendly events
      switch (event.type) {
        case 'agent_run_start':
          // processing
          this.emit('agent-status', { isProcessing: true, state: 'executing' });
          break;

        case 'agent_run_end':
          // 
          this.emit('agent-status', { isProcessing: false, state: event.status || 'idle' });
          break;

        case 'user_message':
          // 
          this.emit('agent-status', { isProcessing: true, state: 'processing' });
          this.emit('query', { text: event.content });
          break;
        case 'assistant_message':
          this.emit('answer', { text: event.content });
          break;
        case 'tool_call':
          this.emit('event', {
            type: 'tool_call',
            name: event.name,
            toolCallId: event.toolCallId,
            arguments: event.arguments,
          });
          break;
        case 'tool_result':
          this.emit('event', {
            type: 'tool_result',
            name: event.name,
            toolCallId: event.toolCallId,
            content: event.content,
            error: event.error,
          });
          break;
        case 'system':
          this.emit(event.level, { message: event.message });
          break;
        default:
          this.emit('event', event);
      }

      // 
      if (event.type === 'system' && event.message?.includes('aborted')) {
        this.emit('aborted', { message: event.message });
        // 
        this.emit('agent-status', { isProcessing: false, state: 'idle' });
      }

      // Add handling for status events
      if (event.type === 'system' && event.message?.includes('status')) {
        this.emit('status', { message: event.message });
      }
    };

    // Subscribe to the Agent's event stream
    return agentEventStream.subscribe(handleEvent);
  }
}
",
      "hasError": false,
      "relativePath": "src/utils/event-stream.ts",
      "size": 3345,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

export * from './error-handler';
export * from './workspace-static-server';
export * from './url';
export * from './agent-resolver';
",
      "hasError": false,
      "relativePath": "src/utils/index.ts",
      "size": 238,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import fs from 'fs';
import path from 'path';
import os from 'os';
import { AgentEventStream, AgentServerVersionInfo } from '@tarko/interface';
import { SessionMetadata } from '../storage';

/**
 * ShareUtils - Utility functions for sharing session data
 *
 * Provides methods for:
 * - Generating HTML for sharing
 * - Uploading share HTML to providers
 * - Uploading individual files to share providers
 */
export class ShareUtils {
  /**
   * Generate shareable HTML content for a session
   * @param events Session events to include
   * @param metadata Session metadata
   * @param staticPath Path to static web UI files
   * @param serverInfo Optional server version info
   * @returns Generated HTML content
   */
  static generateShareHtml(
    events: AgentEventStream.Event[],
    metadata: SessionMetadata,
    staticPath: string,
    serverInfo?: AgentServerVersionInfo,
  ): string {
    if (!staticPath) {
      throw new Error('Cannot found static path.');
    }

    const indexPath = path.join(staticPath, 'index.html');
    if (!fs.existsSync(indexPath)) {
      throw new Error('Static web ui not found.');
    }

    try {
      let htmlContent = fs.readFileSync(indexPath, 'utf8');

      const safeEventJson = this.safeJsonStringify(events);
      const safeMetadataJson = this.safeJsonStringify(metadata);
      const safeVersionJson = serverInfo ? this.safeJsonStringify(serverInfo) : null;

      // Inject session data, event stream, and version info
      const scriptTag = \`<script>
        window.AGENT_REPLAY_MODE = true;
        window.AGENT_SESSION_DATA = \${safeMetadataJson};
        window.AGENT_EVENT_STREAM = \${safeEventJson};\${
          safeVersionJson
            ? \`
        window.AGENT_VERSION_INFO = \${safeVersionJson};\`
            : ''
        }
      </script>
      <script>
        // Add a fallback mechanism for when routes don't match in shared HTML files
        window.addEventListener('DOMContentLoaded', function() {
          // Give React time to attempt normal routing
          setTimeout(function() {
            const root = document.getElementById('root');
            if (root && (!root.children || root.children.length === 0)) {
              console.log('[ReplayMode] No content rendered, applying fallback');
              // Try to force the app to re-render if no content is displayed
              window.dispatchEvent(new Event('resize'));
            }
          }, 1000);
        });
      </script>\`;

      // Insert script before the head end tag
      htmlContent = htmlContent.replace('</head>', \`\${scriptTag}\\n</head>\`);

      return htmlContent;
    } catch (error) {
      console.error('Failed to generate share HTML:', error);
      throw new Error(
        \`Failed to generate share HTML: \${error instanceof Error ? error.message : String(error)}\`,
      );
    }
  }

  /**
   * Safely stringify JSON data containing HTML content
   * This ensures HTML in the data won't break the embedding script
   * @param data The data to stringify
   * @returns Safe JSON string
   */
  private static safeJsonStringify(data: object): string {
    let jsonString = JSON.stringify(data);

    // Escape all characters that may destroy the HTML structure
    // 1. Escape all angle brackets to prevent any HTML tags from being parsed by the browser
    jsonString = jsonString.replace(/</g, '\\\\u003C');
    jsonString = jsonString.replace(/>/g, '\\\\u003E');

    // 2. Escape other potentially dangerous characters
    jsonString = jsonString.replace(/\\//g, '\\\\/'); // Escape slashes to prevent closing tags such as </script>

    return jsonString;
  }

  /**
   * Upload HTML to a share provider
   * @param html HTML content to upload
   * @param sessionId Session ID
   * @param shareProviderUrl URL of the share provider
   * @param options Additional share metadata options
   * @returns URL of the shared content
   */
  static async uploadShareHtml(
    html: string,
    sessionId: string,
    shareProviderUrl: string,
    options?: {
      /**
       * Session metadata containing additional session information
       */
      metadata?: SessionMetadata;

      /**
       * Normalized slug for semantic URLs, derived from user query
       */
      slug?: string;

      /**
       * Original query that initiated the conversation
       */
      query?: string;
    },
  ): Promise<string> {
    if (!shareProviderUrl) {
      throw new Error('Share provider not configured');
    }

    try {
      // Create temporary directory
      const tempDir = path.join(os.tmpdir(), 'agent-tars-share');
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      const fileName = \`agent-tars-\${sessionId}-\${Date.now()}.html\`;
      const filePath = path.join(tempDir, fileName);

      // Write HTML content to temporary file
      fs.writeFileSync(filePath, html);

      // Create form data using native FormData
      const formData = new FormData();

      // Create a File object from the HTML content
      const file = new File([html], fileName, { type: 'text/html' });
      formData.append('file', file);
      formData.append('sessionId', sessionId);
      formData.append('type', 'html'); // Specify this is HTML content

      // Add additional metadata fields if provided
      if (options) {
        // Add normalized slug for semantic URLs
        if (options.slug) {
          formData.append('slug', options.slug);
        }

        // Add original query
        if (options.query) {
          formData.append('query', options.query);
        }

        // Add session metadata fields
        if (options.metadata) {
          formData.append('name', options.metadata.name || '');
          // Add tags if available
          if (options.metadata.tags && options.metadata.tags.length > 0) {
            formData.append('tags', JSON.stringify(options.metadata.tags));
          }
        }
      }

      // Send request to share provider using fetch
      const response = await fetch(shareProviderUrl, {
        method: 'POST',
        body: formData,
      });

      // Clean up temporary file
      fs.unlinkSync(filePath);

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const responseData = await response.json();

      // Return share URL
      if (responseData && responseData.url) {
        return responseData.url;
      }

      throw new Error('Invalid response from share provider');
    } catch (error) {
      console.error('Failed to upload share HTML:', error);
      throw error;
    }
  }

  /**
   * Upload a file to share provider
   * @param filePath Path to the file to upload
   * @param fileName Name for the uploaded file
   * @param shareProviderUrl URL of the share provider
   * @param options Additional upload options
   * @returns URL of the uploaded file
   */
  static async uploadFile(
    filePath: string,
    fileName: string,
    shareProviderUrl: string,
    options?: {
      /**
       * File type (e.g., 'image', 'document')
       */
      type?: string;
      /**
       * Original relative path of the file
       */
      originalPath?: string;
      /**
       * Additional metadata
       */
      metadata?: Record<string, string>;
    },
  ): Promise<string> {
    if (!shareProviderUrl) {
      throw new Error('Share provider not configured');
    }

    if (!fs.existsSync(filePath)) {
      throw new Error(\`File not found: \${filePath}\`);
    }

    try {
      const fileContent = fs.readFileSync(filePath);

      // Create form data using native FormData
      const formData = new FormData();

      // Create a File object from the file content
      const file = new File([fileContent], fileName, {
        type: this.getMimeType(filePath),
      });

      formData.append('file', file);
      formData.append('type', options?.type || 'file');

      if (options?.originalPath) {
        formData.append('originalPath', options.originalPath);
      }

      // Add additional metadata if provided
      if (options?.metadata) {
        for (const [key, value] of Object.entries(options.metadata)) {
          formData.append(key, value);
        }
      }

      // Send request to share provider using fetch
      const response = await fetch(shareProviderUrl, {
        method: 'POST',
        body: formData,
      });

      if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
      }

      const responseData = await response.json();

      // Return file URL
      if (responseData && responseData.url) {
        return responseData.url;
      }

      throw new Error('Invalid response from share provider for file upload');
    } catch (error) {
      console.error(\`Failed to upload file \${filePath}:\`, error);
      throw error;
    }
  }

  /**
   * Get MIME type for a file based on its extension
   */
  private static getMimeType(filePath: string): string {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes: Record<string, string> = {
      // Images
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.png': 'image/png',
      '.gif': 'image/gif',
      '.webp': 'image/webp',
      '.svg': 'image/svg+xml',
      // Documents
      '.pdf': 'application/pdf',
      '.txt': 'text/plain',
      '.md': 'text/markdown',
      '.html': 'text/html',
      '.css': 'text/css',
      '.js': 'application/javascript',
      '.json': 'application/json',
      // Archives
      '.zip': 'application/zip',
      '.tar': 'application/x-tar',
      '.gz': 'application/gzip',
    };

    return mimeTypes[ext] || 'application/octet-stream';
  }
}
",
      "hasError": false,
      "relativePath": "src/utils/share.ts",
      "size": 9794,
    },
    {
      "content": "/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import { IAgent } from '@tarko/interface';

/**
 * Response schema for LLM-generated slug
 */
interface SlugResponse {
  /**
   * Generated slug containing 3-5 words separated by hyphens
   */
  slug: string;
}

/**
 * SlugGenerator - Intelligent slug generation using LLM JSON mode
 *
 * This class provides AI-powered slug generation that can handle multilingual content
 * and produce semantic, URL-friendly slugs. It uses the LLM's JSON mode to ensure
 * structured output and proper formatting.
 *
 * Key features:
 * - Multilingual support (Chinese, English, etc.)
 * - Semantic understanding of content
 * - Consistent 3-5 word length
 * - URL-safe formatting
 * - Internal fallback to manual normalization if LLM fails
 */
export class SlugGenerator {
  constructor(private agent: IAgent) {}

  /**
   * Generate a semantic slug from user message
   * Handles all normalization logic internally, no external fallback needed
   *
   * @param userMessage The original user message to generate slug from
   * @returns Promise resolving to a normalized slug string
   */
  async generateSlug(userMessage: string): Promise<string> {
    if (!userMessage.trim()) {
      return this.getDefaultSlug();
    }

    try {
      // Try LLM-powered generation first
      const llmSlug = await this.generateWithLLM(userMessage);
      if (llmSlug) {
        return llmSlug;
      }
    } catch (error) {
      console.warn('LLM slug generation failed, using manual normalization:', error);
    }

    // Fallback to manual normalization
    return this.manualNormalization(userMessage);
  }

  /**
   * Generate slug using LLM JSON mode
   */
  private async generateWithLLM(userMessage: string): Promise<string | null> {
    const response = await this.agent.callLLM({
      messages: [
        {
          role: 'system',
          content: \`You are a URL slug generator. Generate a semantic, URL-friendly slug from the given text.

Requirements:
- Use 3-5 words separated by hyphens
- Use only lowercase English words
- No special characters except hyphens
- Capture the main topic/intent of the text
- Handle multilingual input (Chinese, English, etc.)
- NEVER include non-ASCII characters like Chinese in the output

Return only a JSON object with a "slug" field.\`,
        },
        {
          role: 'user',
          content: \`Generate a slug for: "\${userMessage}"\`,
        },
      ],
      response_format: { type: 'json_object' },
      temperature: 0.3,
      max_tokens: 100,
    });

    const content = response.choices[0]?.message?.content;
    if (!content) {
      return null;
    }

    try {
      const parsed = JSON.parse(content) as SlugResponse;

      // Apply manual normalization to ensure LLM output is also sanitized
      return this.manualNormalization(parsed.slug);
    } catch (error) {
      console.error('Failed to parse LLM slug response:', error);
      return null;
    }
  }

  /**
   * Manual normalization - the consolidated logic from all places
   */
  private manualNormalization(text: string): string {
    // First, attempt to transliterate non-ASCII characters
    // Then apply standard normalization
    const normalized = text
      .toLowerCase()
      // First, remove all non-ASCII characters completely
      .replace(/[^\\x00-\\x7F]+/g, '-')
      .replace(/[^\\w\\s-]/g, '') // Remove remaining special characters
      .replace(/\\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Remove consecutive hyphens
      .substring(0, 60) // Limit length
      .replace(/^-+|-+$/g, ''); // Remove leading/trailing hyphens

    if (!normalized || normalized.length === 0) {
      return this.getDefaultSlug();
    }

    // Take first few words if too long
    const words = normalized.split('-').filter((word) => word.length > 0);
    return words.slice(0, 4).join('-') || this.getDefaultSlug();
  }

  /**
   * Get default slug when all else fails
   */
  private getDefaultSlug(): string {
    return 'untitled-session';
  }
}
",
      "hasError": false,
      "relativePath": "src/utils/slug-generator.ts",
      "size": 4101,
    },
    {
      "content": "/**
 * Ensure URL has HTTPS prefix
 */
export function ensureHttps(url: string): string {
  if (!url) return url;

  if (url.startsWith('http://') || url.startsWith('https://')) {
    if (url.startsWith('http://')) {
      return url.replace('http://', 'https://');
    }
    return url;
  }

  if (url.startsWith('//')) {
    return \`https:\${url}\`;
  }

  return \`https://\${url}\`;
}
",
      "hasError": false,
      "relativePath": "src/utils/url.ts",
      "size": 384,
    },
    {
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */
/*
 * Copyright (c) 2025 Bytedance, Inc. and its affiliates.
 * SPDX-License-Identifier: Apache-2.0
 */

import express from 'express';
import path from 'path';
import fs from 'fs';

/**
 * Extract session ID from referer URL
 * @param referer The referer header value
 * @returns Session ID or null if not found
 */
function extractSessionIdFromReferer(referer: string | undefined): string | undefined {
  if (!referer) {
    return;
  }

  try {
    const url = new URL(referer);
    const pathParts = url.pathname.split('/').filter(Boolean);

    // Assume the last non-empty path segment is the session ID
    // You might want to adjust this logic based on your URL structure
    if (pathParts.length > 0) {
      const potentialSessionId = pathParts[pathParts.length - 1];

      // Basic validation - session ID should be alphanumeric and of reasonable length
      if (/^[a-zA-Z0-9_-]{10,}$/.test(potentialSessionId)) {
        return potentialSessionId;
      }
    }
  } catch (error) {
    // Invalid URL, ignore
  }

  return;
}

/**
 * Workspace file resolver that handles session isolation and absolute paths
 */
export class WorkspaceFileResolver {
  constructor(private baseWorkspacePath: string) {}

  /**
   * Resolve file path considering session isolation and security
   * @param requestPath The requested file path
   * @param sessionId Optional session ID for isolated sessions
   * @returns Resolved file path or null if not found/not allowed
   */
  resolveFilePath(requestPath: string, sessionId?: string): string | null {
    // Security check: prevent path traversal
    const normalizedPath = path.normalize(requestPath);
    if (normalizedPath.includes('..')) {
      return null;
    }

    const pathsToTry: string[] = [];

    pathsToTry.push(normalizedPath);

    // Always try the base workspace path as fallback
    const basePath = path.join(this.baseWorkspacePath, normalizedPath);
    pathsToTry.push(basePath);

    // Find the first existing file
    for (const filePath of pathsToTry) {
      if (this.isPathSafe(filePath) && fs.existsSync(filePath)) {
        return filePath;
      }
    }

    return null;
  }

  /**
   * Security check: ensure the resolved path is within allowed directories
   */
  private isPathSafe(filePath: string): boolean {
    const resolvedPath = path.resolve(filePath);
    const resolvedWorkspace = path.resolve(this.baseWorkspacePath);

    return resolvedPath.startsWith(resolvedWorkspace);
  }

  /**
   * List all accessible directories for a given session
   * @param sessionId Optional session ID
   * @returns Array of accessible directory paths
   */
  getAccessibleDirectories(sessionId?: string): string[] {
    const directories: string[] = [];

    // Add base workspace directory
    if (fs.existsSync(this.baseWorkspacePath)) {
      directories.push(this.baseWorkspacePath);
    }

    return directories;
  }
}

/**
 * Handle directory listing with session-aware navigation
 */
function handleDirectoryListing(
  req: express.Request,
  res: express.Response,
  directoryPath: string,
  fileResolver: WorkspaceFileResolver,
  sessionId: string | undefined,
  baseWorkspacePath: string,
): express.Response {
  try {
    const files = fs.readdirSync(directoryPath).map((file) => {
      const filePath = path.join(directoryPath, file);
      const fileStats = fs.statSync(filePath);
      return {
        name: file,
        isDirectory: fileStats.isDirectory(),
        size: fileStats.size,
        modified: fileStats.mtime,
      };
    });

    const relativePath = path.relative(baseWorkspacePath, directoryPath);
    const breadcrumb = relativePath ? relativePath.split(path.sep) : [];

    // Add session context to the listing
    const sessionContext = sessionId ? \` (Session: \${sessionId})\` : '';
    const html = generateDirectoryListingHTML(
      files,
      req.path,
      breadcrumb,
      sessionContext,
      sessionId,
    );
    return res.send(html);
  } catch (error) {
    return res.status(500).json({ error: 'Failed to read directory' });
  }
}

/**
 * Generate HTML for directory listing with session context
 */
function generateDirectoryListingHTML(
  files: Array<{ name: string; isDirectory: boolean; size: number; modified: Date }>,
  currentPath: string,
  breadcrumb: string[],
  sessionContext = '',
  sessionId?: string,
): string {
  const title = \`Directory: \${currentPath}\${sessionContext}\`;

  const breadcrumbHTML =
    breadcrumb.length > 0
      ? breadcrumb
          .map((part, index) => {
            const href = '/' + breadcrumb.slice(0, index + 1).join('/');
            const sessionParam = sessionId ? \`?sessionId=\${sessionId}\` : '';
            return \`<a href="\${href}\${sessionParam}">\${part}</a>\`;
          })
          .join(' / ')
      : 'workspace';

  const parentLink =
    currentPath !== '/'
      ? \`<tr><td><a href="\${path.dirname(currentPath)}\${sessionId ? \`?sessionId=\${sessionId}\` : ''}"> ..</a></td><td>-</td><td>-</td></tr>\`
      : '';

  const fileRows = files
    .sort((a, b) => {
      // Directories first, then files
      if (a.isDirectory && !b.isDirectory) return -1;
      if (!a.isDirectory && b.isDirectory) return 1;
      return a.name.localeCompare(b.name);
    })
    .map((file) => {
      const icon = file.isDirectory ? '' : '';
      const href = path.join(currentPath, file.name).replace(/\\\\/g, '/');
      const sessionParam = sessionId ? \`?sessionId=\${sessionId}\` : '';
      const size = file.isDirectory ? '-' : formatFileSize(file.size);
      const modified =
        file.modified.toLocaleDateString() + ' ' + file.modified.toLocaleTimeString();

      return \`<tr>
        <td><a href="\${href}\${sessionParam}">\${icon} \${file.name}</a></td>
        <td>\${size}</td>
        <td>\${modified}</td>
      </tr>\`;
    })
    .join('');

  return \`<!DOCTYPE html>
<html>
<head>
    <title>\${title}</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        h1 { color: #333; border-bottom: 1px solid #ddd; padding-bottom: 10px; }
        .breadcrumb { margin-bottom: 20px; color: #666; }
        .session-info { margin-bottom: 20px; padding: 10px; background-color: #f0f8ff; border-radius: 5px; color: #0066cc; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px 12px; text-align: left; border-bottom: 1px solid #eee; }
        th { background-color: #f5f5f5; font-weight: bold; }
        a { text-decoration: none; color: #0066cc; }
        a:hover { text-decoration: underline; }
        .footer { margin-top: 40px; padding-top: 20px; border-top: 1px solid #ddd; color: #666; font-size: 12px; }
    </style>
</head>
<body>
    <h1>Agent Workspace\${sessionContext}</h1>
    \${sessionId ? \`<div class="session-info"> Browsing files for session: <strong>\${sessionId}</strong></div>\` : ''}
    <div class="breadcrumb"> \${breadcrumbHTML}</div>
    <table>
        <thead>
            <tr>
                <th>Name</th>
                <th>Size</th>
                <th>Modified</th>
            </tr>
        </thead>
        <tbody>
            \${parentLink}
            \${fileRows}
        </tbody>
    </table>
    <div class="footer">
        Agent Workspace Static Server\${sessionContext}
        \${sessionId ? \`<br/>Tip: Remove <code>?sessionId=\${sessionId}</code> from URL to browse base workspace\` : ''}
    </div>
</body>
</html>\`;
}

/**
 * Format file size in human readable format
 */
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

/**
 * Setup workspace static server with session isolation support
 * Serves static files from workspace directories with proper session handling
 * @param app Express application instance
 * @param workspacePath Path to workspace directory
 * @param isDebug Whether to show debug logs
 */
export function setupWorkspaceStaticServer(
  app: express.Application,
  workspacePath: string,
  isDebug = false,
): void {
  if (!workspacePath || !fs.existsSync(workspacePath)) {
    if (isDebug) {
      console.log('Workspace path not found, skipping static server setup');
    }
    return;
  }

  if (isDebug) {
    console.log(\`Setting up workspace static server at: \${workspacePath}\`);
  }

  const fileResolver = new WorkspaceFileResolver(workspacePath);

  // Serve workspace files with lower priority (after web UI)
  // Use a middleware function to handle directory listing and file serving
  app.use('/', (req, res, next) => {
    // Skip if this looks like an API request
    if (req.path.startsWith('/api/')) {
      return next();
    }

    // Skip if this looks like a web UI route (no file extension and not a static asset)
    if (
      !req.path.includes('.') &&
      !req.path.startsWith('/static/') &&
      !req.path.startsWith('/assets/')
    ) {
      return next();
    }

    // Try to extract session ID from query params or headers
    const sessionId =
      (req.query.sessionId as string) ||
      (req.headers['x-session-id'] as string) ||
      extractSessionIdFromReferer(req.headers.referer);

    // Resolve the file path using the file resolver
    const resolvedPath = fileResolver.resolveFilePath(req.path, sessionId);
    if (!resolvedPath) {
      return next();
    }

    try {
      const stats = fs.statSync(resolvedPath);

      if (stats.isFile()) {
        // Serve the file
        return res.sendFile(resolvedPath);
      } else if (stats.isDirectory()) {
        // For directories, try to serve index.html or provide directory listing
        const indexPath = path.join(resolvedPath, 'index.html');
        if (fs.existsSync(indexPath)) {
          return res.sendFile(indexPath);
        } else {
          // Provide directory listing with session context
          return handleDirectoryListing(
            req,
            res,
            resolvedPath,
            fileResolver,
            sessionId,
            workspacePath,
          );
        }
      }
    } catch (error) {
      // File access error, continue to next middleware
      return next();
    }

    // File not found, continue to next middleware
    next();
  });
}
",
      "hasError": false,
      "relativePath": "src/utils/workspace-static-server.ts",
      "size": 10420,
    },
  ],
  "processedDirectories": [
    "/Users/chenhaoli/workspace/code/UI-TARS-desktop-5/multimodal/tarko/agent-server/src",
  ],
  "stats": {
    "errorCount": 0,
    "totalFiles": 38,
    "totalSize": 133715,
  },
}
`;
